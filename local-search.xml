<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Golang 学习笔记——go 包的使用</title>
    <link href="/2022/07/31/Golang-package-note/"/>
    <url>/2022/07/31/Golang-package-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-包的使用"><a href="#Go-包的使用" class="headerlink" title="Go 包的使用"></a>Go 包的使用</h1><p>关于包的使用:  </p><ol><li>一个目录下的文件归属一个包。<code>package</code> 的声明要一致  </li><li>package声明的包和对应的目录名可以不一致。但习惯上还是写成一致的  </li><li>包可以嵌套  </li><li>同包下的函数不需要导入包，可以直接使用  </li><li>main包，<code>main()</code> 函数所在的包，其他的包不能使用  </li><li>导入包的时候，路径要从 <code>src</code> 下开始写  </li><li><strong>变量名大写</strong> 表示该变量可以外部访问.</li></ol><h2 id="init-函数"><a href="#init-函数" class="headerlink" title="init() 函数"></a><code>init()</code> 函数</h2><p><code>init()</code>、<code>main()</code> 是 Go 语言中的保留函数。我们可以在源码中，定义 <code>init()</code> 函数。此函数会在<strong>包被导入时执行</strong>，例如如果是在 <code>main()</code> 中导入包，包中存在 <code>init()</code>,那么 <code>init()</code> 中的代码会在 <code>main()</code> 函数执行前执行，用于初始化包所需要的特定资料.    </p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ol><li><code>init()</code> <code>main()</code> 函数不能有返回值也不能有参数.  </li><li>两个函数在定义时不能有任何的参数和返回值,该函数只能由 Go 程序自动调用,不可以被引用.</li></ol><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ol><li><code>init()</code> 可以应用于任意包中，且可以重复定义多个。  </li><li><code>main()</code> 函数只能用于 <code>main</code> 包中，且只能定义一个。</li></ol><h2 id="两个函数的执行顺序"><a href="#两个函数的执行顺序" class="headerlink" title="两个函数的执行顺序"></a>两个函数的执行顺序</h2><ol><li><p>对于同一个 Go 文件,从上到下执行<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/package-1.png">  </p></li><li><p>对于同一个 package 中的不同文件,将文件名按字符串进行从小到大排序,之后顺序调用各文件中的 <code>init()</code> 函数.<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/package-2.png">  </p></li><li><p>对于不同的 package,如果不相互依赖的话，按照 main 包中 import 的顺序调用其他包中的 <code>init()</code> 函数。    </p></li><li><p>如果 package 存在依赖,调用顺序为最后被依赖的最先被初始化.<br>例如：导入顺序 main-&gt;A-&gt;B-&gt;C ,则初始化顺序为 C-&gt;B-&gt;A-&gt;main ,一次执行对应的init方法。main包总是被最后一个初始化，因为它总是依赖别的包.<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/package-3.png">  </p></li><li><p>避免出现 <strong>循环 import</strong> ,例如：<code>A-&gt;B-&gt;C-&gt;A</code>.<br>一个包被其它多个包 import ,.但只能被初始化一次</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>init()</code> 函数和 <code>main()</code> 函数</p><ol><li>这两个函数都是go语言中的<strong>保留函数</strong>。<code>init()</code> 用于初始化信息，<code>main()</code> 用于作为<strong>程序的入口</strong></li><li>这两个函数定义的时候：<strong>不能有参数，返回值</strong>。只能由 Go 程序自动调用，<strong>不能被引用</strong></li><li><code>init()</code> 函数可以定义在任意的包中，可以有多个。<code>main()</code> 函数只能在 main 包下，并且<strong>只能有一个</strong>。</li><li>执行顺序<ol><li>先执行 <code>init()</code> 函数，后执行 <code>main()</code> 函数  </li><li>对于同一个 Go 文件中，调用顺序是<strong>从上到下</strong>的，也就是说，先写的先被执行，后写的后被执行  </li><li>对于同一个包下，将文件名按照字符串进行排序，之后顺序调用各个文件中 <code>init()</code> 函数  </li><li>对于不同包下.<br>如果不存在依赖，按照 main 包中 import 的顺序来调用对应包中   <code>init()</code> 函数如果存在依赖，<strong>最后被依赖的最先被初始化</strong><br>导入顺序：main一&gt;A一&gt;B-&gt;C<br>执行顺序：C一&gt;B-&gt;A一&gt;main</li></ol></li><li>存在依赖的包之间，不能循环导入   </li><li>一个包可以被其他多个包 import ,但是 <strong>只能被初始化一次</strong>。  </li><li><code>_</code> 操作，其实是<strong>引入该包</strong>，而不直接使用包里面的函数，仅仅是调用了该包里的 <code>init()</code></li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li><p>如果仅仅需要导入包时执行<strong>初始化操作</strong>，并不需要使用包内的<strong>其他函数</strong>，常量等资源。则可以在导入包时，<strong>匿名导入</strong>。<br>这个操作经常是让<strong>很多人费解</strong>的一个操作符  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用 `_`(空白标识符) 匿名导入.</span><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;database/sql&quot;</span><br>    _ <span class="hljs-string">&quot;github.com/ziutek/mymysql/godrv&quot;</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>管理外部包<br>Go 允许 import 不同代码库的代码。对于 import 要导入的外部的包，可以使用 <code>Go get</code> 命令取下来放到 <code>GOPATHS</code> 对应的目录中去。<br>举个例子，比如说我们想通过 Go 语言连接 mysql 数据库，那么需要先下载 mysql 的数据包，打开终端并输入以下命令：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/go-sql-driver/mysql<br></code></pre></td></tr></table></figure><p>安装之后，就可以在 <code>GOPATHS</code> 目录的 <code>src</code> 下，看到对应的文件包目录.   </p><blockquote><p>如果有多个 <code>GOPATHS</code> 目录,默认下载到第一个目录下.</p></blockquote></li><li><p>我们可以通过 <code>go install</code> 来编译包文件。<br>我们知道一个非main包在编译后会生成一个。a文件(在临时目录下生成)。除非使用go install安装到 <code>$GOROOT</code> 或 <code>$GOPATH</code> 下，否则你看不到a,用于后续可执行程序链接使用。<br>比如Go标准库中的包对应的源码部分路径在：<code>$GROOT/src</code>,而标准库中包编译后的a文件路径在 <code>$GROOT/pkg/darwin_amd64</code> 下。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——Go error 错误</title>
    <link href="/2022/05/21/Golang-error-note/"/>
    <url>/2022/05/21/Golang-error-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-error-错误"><a href="#Go-error-错误" class="headerlink" title="Go error 错误"></a>Go error 错误</h1><p>在实际工程项目中，我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。Go语言没有提供像<code>Java</code>、<code>c#</code> 语言中的 <code>try..catch</code> 异常处理方式，而是通过 <strong>函数返回值</strong> 逐层往上抛。这种设计，鼓励工程师在代码中 <strong>显式的检查错误</strong> ，而非忽略错误，好处就是避免漏掉本应处理的错误。但是带来一个弊端，让 <strong>代码啰嗦</strong> 。</p><h2 id="错误-amp-异常"><a href="#错误-amp-异常" class="headerlink" title="错误&amp;异常"></a>错误&amp;异常</h2><ul><li><strong>错误</strong>: 指的是<strong>可能出现问题</strong>的地方出现了问题。比如打开一个文件时失败，这种情况在人们的意料之中。  </li><li><strong>异常</strong>: 指的是不<strong>应该出现问题</strong>的地方出现了问题。比如引用了空指针，这种情况<strong>在人们的意料之外</strong>。可见，错误是业务过程的一部分，而异常不是。</li></ul><p>Go中的错误 <strong>也是一种类型</strong> 。错误用内置的 <code>error</code> 类型表示。就像其他类型的，如<code>int</code>,<code>floate64</code>.错误值可以<strong>存储在变量中，从函数中返回</strong>，等等。</p><h2 id="处理-OS-模块异常"><a href="#处理-OS-模块异常" class="headerlink" title="处理 OS 模块异常"></a>处理 OS 模块异常</h2><p>如果一个函数或方法返回一个错误，那么按照惯例，它必须是 <strong>函数返回的最后一个值</strong>。因此，<code>Open</code> 函数返回的值是最后一个值。<br>处理错误的惯用方法是将 <strong>返回的错误与 <code>nil</code> 进行比较</strong> 。<code>nil</code> 值表示没有发生错误，而 <code>非nil</code> 值表示出现错误。在我们的例子中，我们检查错误是否为<code>nil</code>。如果它不是 <code>nil</code> ,我们只需 <strong>打印错误并从主函数返回</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//打开一个文件</span><br>    f,err := os.Open(name:<span class="hljs-string">&quot;test.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<br>        <span class="hljs-comment">//log.Fatal(err)  //调用日志模块捕捉异常,会自动 return</span><br>        fmt.Println(err) <span class="hljs-comment">//异常信息:open test.txt:no such file directoryreturn</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>  fmt.Println(f.Name(),<span class="hljs-string">&quot;打开文件成功。。&quot;</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误类型表示"><a href="#错误类型表示" class="headerlink" title="错误类型表示"></a>错误类型表示</h2><p>G0语言通过 <strong>内置的错误接口</strong> 提供了非常简单的错误处理机制。<br><strong>定义错误类型</strong> 的构建。错误是一个带有以下定义的接口类型:  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>fmt.Println(err)</code> 会在内部执行 Error() 方法,返回错误的字符串信息.  </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/error-1.png">  </p><h3 id="从错误中获取更多信息"><a href="#从错误中获取更多信息" class="headerlink" title="从错误中获取更多信息"></a>从错误中获取更多信息</h3><blockquote><p><strong>断言判断接口底层类型</strong> ,通过 <code>struct</code> 结构体的属性和方法获取更多的信息</p></blockquote><h4 id="使用-struct-类型属性"><a href="#使用-struct-类型属性" class="headerlink" title="使用 struct 类型属性"></a>使用 <code>struct</code> 类型属性</h4><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/error-4.png">  </p><h4 id="调用-struct-类型的方法"><a href="#调用-struct-类型的方法" class="headerlink" title="调用 struct 类型的方法"></a>调用 <code>struct</code> 类型的方法</h4><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/error-5.png">  </p><h4 id="直接比较"><a href="#直接比较" class="headerlink" title="直接比较"></a>直接比较</h4><p>直接与错误类型的变量进行比较.  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;path/filepath&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  files,err := filepath.Glob(<span class="hljs-string">&quot;[&quot;</span>)<br>  <span class="hljs-comment">// 直接判断错误的类型</span><br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp; err == filepath.ErrBadPattern&#123;<br>    fmt.Println(err)<span class="hljs-comment">//syntax error in patternreturn</span><br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  fmt.Println(a:<span class="hljs-string">&quot;files:&quot;</span>,files)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义-error"><a href="#自定义-error" class="headerlink" title="自定义 error"></a>自定义 error</h2><h3 id="1-通过-errors-New-quot-描述-quot"><a href="#1-通过-errors-New-quot-描述-quot" class="headerlink" title="1. 通过 errors.New(&quot;描述&quot;)"></a>1. 通过 <code>errors.New(&quot;描述&quot;)</code></h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/error-2.png"></p><h3 id="2-通过-fmt-Errorf"><a href="#2-通过-fmt-Errorf" class="headerlink" title="2. 通过 fmt.Errorf()"></a>2. 通过 <code>fmt.Errorf()</code></h3><p>也可以使用 <code>fmt.Errorf()</code> 输出的错误更详细,支持格式化输出错误.  </p><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/error-3.png">  </p><h3 id="3-定义错误"><a href="#3-定义错误" class="headerlink" title="3. 定义错误"></a>3. 定义错误</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := <span class="hljs-number">-2.0</span><br>area, err := circleArea(r)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 打印 err 就是调用错误struct的Error()方法,返回字符串</span><br>        <span class="hljs-comment">//错误值其实就是错误对象调用Error方法执行的结果</span><br><span class="hljs-comment">// fmt.Println(err)</span><br><span class="hljs-comment">// 通过接口断言判断错误类型,获取错误类型中的属性,运行错误类型中的方法</span><br><span class="hljs-keyword">if</span> err, ok := err.(*areaError); ok &#123;<br>fmt.Println(err)<br>fmt.Printf(<span class="hljs-string">&quot;半径是:%.2f\n&quot;</span>, err.radius)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(err)<br>fmt.Printf(<span class="hljs-string">&quot;其他错误类型:%s,%T\n&quot;</span>, err, err)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;圆的的面积是:&quot;</span>, area)<br>&#125;<br><br><span class="hljs-comment">//1. 定义一个struct,表示错误类型</span><br><span class="hljs-keyword">type</span> areaError <span class="hljs-keyword">struct</span> &#123;<br>msg    <span class="hljs-type">string</span> <span class="hljs-comment">// 错误的描述</span><br>radius <span class="hljs-type">float64</span>  <span class="hljs-comment">//半径</span><br>&#125;<br><br><span class="hljs-comment">//2. 实现error接口，就是实现Error方法，该方法返回字符串</span><br><span class="hljs-comment">// 需要传入结构体指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *areaError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// 返回一个格式化的字符串</span><br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;error: 半径,%.2f,%s&quot;</span>, e.radius, e.msg)<br>&#125;<br><br><span class="hljs-comment">// 3.定义一个求圆面积的函数,注意，第二个返回值是go内置的 error接口实现类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">circleArea</span><span class="hljs-params">(r <span class="hljs-type">float64</span>)</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 用 &amp; 返回error对象指针</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, &amp;areaError&#123;<span class="hljs-string">&quot;半径是非法的&quot;</span>, r&#125;<br>&#125;<br><span class="hljs-keyword">return</span> math.Pi * r * r, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="尽量不要-忽略错误"><a href="#尽量不要-忽略错误" class="headerlink" title="尽量不要 _ 忽略错误"></a>尽量不要 <code>_</code> 忽略错误</h2><p><strong>永远不要忽略一个错误。忽视错误会招致麻烦。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">files,_ := filepath.Glob(<span class="hljs-string">&quot;[&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="panic-和-recover"><a href="#panic-和-recover" class="headerlink" title="panic() 和 recover()"></a><code>panic()</code> 和 <code>recover()</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 处理 panic 的 defer 匿名函数</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// reconver() 接受 panic() 的信息</span><br><span class="hljs-keyword">if</span> msg := <span class="hljs-built_in">recover</span>(); msg != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(msg, <span class="hljs-string">&quot;程序恢复啦。。&quot;</span>)<br>&#125;<br>&#125;()<br><span class="hljs-comment">// funB的panic传递到此处,引起panic时需要执行完所有defer主函数才会报错</span><br>funB()<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myprint</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;<br>fmt.Println(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funB</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//外围函数</span><br><span class="hljs-comment">// 匿名函数,处理pianic的recover()也可以放在main函数中</span><br><span class="hljs-comment">// defer是逆序执行的</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// reconver() 接受 panic() 的信息</span><br><span class="hljs-keyword">if</span> msg := <span class="hljs-built_in">recover</span>(); msg != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(msg, <span class="hljs-string">&quot;程序恢复啦。。&quot;</span>)<br>&#125;<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;我是函数funB()..&quot;</span>)<br><span class="hljs-keyword">defer</span> myprint(<span class="hljs-string">&quot;defer funB()...1.....&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;i:&quot;</span>, i)<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">5</span> &#123;<br><span class="hljs-comment">//让程序中断</span><br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;funB函数,恐慌了&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-comment">//当外围函数的代码中发生了运行恐慌，只有其中所有的已经`defer`的函数全部都执行完毕后，</span><br><span class="hljs-comment">//该运行恐慌才会真正被扩展至调用处。</span><br><span class="hljs-keyword">defer</span> myprint(<span class="hljs-string">&quot;defer funB():2.....&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="什么时候使用错误-x2F-异常"><a href="#什么时候使用错误-x2F-异常" class="headerlink" title="什么时候使用错误&#x2F;异常"></a>什么时候使用错误&#x2F;异常</h2><p>什么情况下用错误表达，什么情况下用异常表达，就得有一套规则，否则很容易出现一切皆错误或一切皆异常的情况。<br>以下给出异常处理的作用域（场景）:  </p><blockquote><ol><li>空指针引用</li><li>下标越界</li><li>除数为0</li><li>不应该出现的分支，比如default</li><li>输入不应该引起函数错误</li></ol></blockquote><p>其他场景我们使用错误处理，这使得我们的函数接口很精炼。对于异常，我们可以选择在一个合适的上游去<code>recover()</code> .并打印堆栈信息，使得部署后的程序不会终止。  </p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——Type关键字</title>
    <link href="/2022/05/21/Golang-type-keyword-note/"/>
    <url>/2022/05/21/Golang-type-keyword-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Type关键字"><a href="#Go-Type关键字" class="headerlink" title="Go Type关键字"></a>Go Type关键字</h1><p><code>type</code> 是Go语法里的重要而且常用的关键字,<code>type</code> 绝不只是对应于C&#x2F;C+中的 <code>typedef</code>.搞清楚 <code>type</code> 的使用,就容易理解Go语言中的核心概念 <code>struct</code>、<code>interface</code>、<code>函数</code> 等的使用。</p><h2 id="通过-type-定义新类型"><a href="#通过-type-定义新类型" class="headerlink" title="通过 type 定义新类型"></a>通过 type 定义新类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> 类型名 Typde<br><span class="hljs-keyword">type</span> myint <span class="hljs-type">int</span>  <span class="hljs-comment">//定义了一共 `myint` 类型它是 `int` 类型</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/type-2.png">  </p><h2 id="通过-type-定义函数类型"><a href="#通过-type-定义函数类型" class="headerlink" title="通过 type 定义函数类型"></a>通过 type 定义函数类型</h2><p>Go 语言支持 <strong>高阶函数</strong> ,所以可以把函数作为一个函数的返回值,或者一个函数的参数.<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/type-1.png">  </p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>常常用于代码迁移,适配新旧代码.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//不是重新定义新的数据类型，只是给int起别名，和int可以通用,%T打印的类型还是int</span><br><span class="hljs-keyword">type</span> myint = <span class="hljs-type">int</span> <br></code></pre></td></tr></table></figure><h2 id="非本地类型不能定义方法"><a href="#非本地类型不能定义方法" class="headerlink" title="非本地类型不能定义方法"></a>非本地类型不能定义方法</h2><p><code>time</code> 包下的 <code>Duration</code> 类型不是 <code>main</code> 包下的类型,所以不是本地类型.不能定义方法.</p><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/type-3.png">  </p><h2 id="在结构体成员嵌入时使用别名"><a href="#在结构体成员嵌入时使用别名" class="headerlink" title="在结构体成员嵌入时使用别名"></a>在结构体成员嵌入时使用别名</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/type-4.png">  </p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——Go 接口</title>
    <link href="/2022/05/16/Golang-interface-note/"/>
    <url>/2022/05/16/Golang-interface-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-接口"><a href="#Go-接口" class="headerlink" title="Go 接口"></a>Go 接口</h1><p><strong>面向对象</strong> 世界中的接口的一般定义是”<strong>接口定义对象的行为</strong>“。它表示让指定对象应该做什么。实现这种行为的方法（实现细节）是<strong>针对对象</strong>的。<br>在 <code>Go</code> 中，接口是<strong>一组方法签名</strong>。当类型为接口中的所有方法提供定义时，它被称为<strong>实现接口</strong>。它与OOP非常相似。接口指定了类型<strong>应该具有</strong>的方法，类型决定了<strong>如何实现</strong>这些方法。</p><blockquote><p>它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口<br>接口定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了该接口。</p></blockquote><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-1.png">  </p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-2.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-4.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-3.png">  </p><blockquote><p>Go语言中接口和类型的实现方式是<strong>非侵入式</strong>的,接口定义的方法没有具体代码.</p></blockquote><h2 id="通过接口模拟多态"><a href="#通过接口模拟多态" class="headerlink" title="通过接口模拟多态"></a>通过接口模拟多态</h2><h3 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h3><p>“一个事物的多种形态”<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-5.png">  </p><p>就一个接口的实现:  </p><ol><li>看成<strong>实现本身的类型</strong>，能够访问<strong>实现类中的属性和方法</strong>.  </li><li>看成是<strong>对应的接口类型</strong>，那就<strong>只能够访问接口中的方法</strong>.</li></ol><p>接口的用法：  </p><ol><li>一个函数如果接受<strong>接口类型作为参数</strong>，那么实际上<strong>可以传入该接口的任意实现类</strong>对象作为参数。  </li><li>定义一个类型为<strong>接口类型</strong>，实际上可以<strong>赋值为任意实现类的对象</strong>.</li></ol><p>鸭子类型:  </p><blockquote><p>待补充…</p></blockquote><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p><code>interface&#123;&#125;</code> 不包含任何的方法,所以<strong>任何类型都是空接口的实现类</strong>,因此空接口可以储存任何类型的数值.<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-7.png">  </p><h3 id="空接口定义任意类型的数据"><a href="#空接口定义任意类型的数据" class="headerlink" title="空接口定义任意类型的数据"></a>空接口定义任意类型的数据</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-6.png">  </p><h3 id="空接口作为函数的参数"><a href="#空接口作为函数的参数" class="headerlink" title="空接口作为函数的参数"></a>空接口作为函数的参数</h3><p>表示函数的参数可以是任意类型,相当于 Python 的 <code>typing.Any</code>  </p><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-8.png"><br><code>fmt</code> 包就是应用了空接口,可以传入任何参数.<br><code>fmt</code> 包下的 <code>Print</code> 系列函数:  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span><span class="hljs-params">(a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (n <span class="hljs-type">int</span>,err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Printf</span><span class="hljs-params">(format <span class="hljs-type">string</span>,a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (n <span class="hljs-type">int</span>,err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Println</span><span class="hljs-params">(a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (n <span class="hljs-type">int</span>,err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><h3 id="复合数据结构使用空接口"><a href="#复合数据结构使用空接口" class="headerlink" title="复合数据结构使用空接口"></a>复合数据结构使用空接口</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-9.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-10.png">  </p><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>接口允许多继承.<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-11.png"><br>如果 Cat 想实现接口C,不仅要实现接口C自己的方法,还要实现接口C继承的接口A B中的方法.<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-12.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-13.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/insterface-14.png">  </p><h2 id="接口断言"><a href="#接口断言" class="headerlink" title="接口断言"></a>接口断言</h2><p>前面说过，因为空接口 <code>interface</code> 没有定义任何函数，因此 <code>Go</code> 中<strong>所有类型都实现了空接口</strong>。当一个函数的形参是 <code>interface&#123;&#125;</code> ,那么在函数中，需要对形参<strong>进行断言</strong>，从而<strong>得到它的真实类型</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-15.png">  </p><p>方法一:<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-16.png"><br>方法二:<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/interface-17.png">  </p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——method方法</title>
    <link href="/2022/05/06/Golang-method-note/"/>
    <url>/2022/05/06/Golang-method-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-方法"><a href="#Go-方法" class="headerlink" title="Go 方法"></a>Go 方法</h1><p>G0语言中同时有函数和方法。一个方法就是一个<strong>包含了接受者的函数</strong>，接受者可以是<strong>命名类型或者结构体类型</strong>的一个<strong>值</strong>或者是一个<strong>指针</strong>。所有给定类型的方法属于<strong>该类型的方法集</strong>.<br>方法只是一个<strong>函数</strong>，它带有一个<strong>特殊的接收器类型</strong>，它是在 <code>func</code> 关键字和方法名之间编写的。接收器可以是 <code>struct</code> 类型或非 <code>struct</code> 类型。<strong>接收方可以在方法内部访问</strong>。  </p><h2 id="对比函数"><a href="#对比函数" class="headerlink" title="对比函数"></a>对比函数</h2><ul><li>意义<br>方法：某个类别的行为功能，需要<strong>指定的接受者调用</strong>.<br>函数：一段<strong>独立功能</strong>的代码，可以直接调用.  </li><li>语法<br>方法：方法名可以相同，只要接受者不同.<br>函数：命名不能冲突.  <blockquote><p>方法可以模拟 <code>class</code> 继承结构.</p></blockquote></li></ul><h2 id="定义一个方法"><a href="#定义一个方法" class="headerlink" title="定义一个方法"></a>定义一个方法</h2><p>语法:  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(接收者)</span></span> 方法名(参数列表)(返回值列表)&#123;<br>    <span class="hljs-comment">// do..something..</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接收者为一个值"><a href="#接收者为一个值" class="headerlink" title="接收者为一个值"></a>接收者为一个值</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/method-1.png">  </p><h3 id="接收者为一个指针"><a href="#接收者为一个指针" class="headerlink" title="接收者为一个指针"></a>接收者为一个指针</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/method-2.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/method-3.png">  </p><h2 id="方法的继承性"><a href="#方法的继承性" class="headerlink" title="方法的继承性"></a>方法的继承性</h2><h3 id="OOP继承"><a href="#OOP继承" class="headerlink" title="OOP继承"></a>OOP继承</h3><p>如果两个类(class)存在<strong>继承关系</strong>，其中一个是子类，另一个作为父类，那么：</p><ol><li>子类可以<strong>直接访问</strong>父类的属性和方法</li><li>子类可以<strong>新增</strong>自己的属性和方法</li><li>子类可以<strong>重写</strong>父类的方法(就是将父类已有的方法，<strong>重新实现</strong>)</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><code>method</code> 是可以继承的，如果匿名字段实现了一个<code>method</code>,那么包含这个匿名字段的 <code>struct</code> 也能调用该 <code>method</code><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/method-4.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/method-5.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/method-6.png">  </p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——struct结构体</title>
    <link href="/2022/05/02/Golang-struct-note/"/>
    <url>/2022/05/02/Golang-struct-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-结构体"><a href="#Go-结构体" class="headerlink" title="Go 结构体"></a>Go 结构体</h1><p><strong>结构体:</strong> 是由一系列具有 <strong>相同类型</strong> 或 <strong>不同类型</strong> 的数据构成的数据 <strong>集合</strong>.<br>结构体成员是由 <strong>一系列的成员变量</strong> 构成，这些 <strong>成员变量</strong> 也被称为 <strong>字段</strong></p><h2 id="定义一个结构体"><a href="#定义一个结构体" class="headerlink" title="定义一个结构体"></a>定义一个结构体</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-1.png"><br>初始化结构体:<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-2.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-3.png"><br>如果不赋值,默认存储的是类型的0值</p><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-4.png">  </p><h3 id="定义结构体指针"><a href="#定义结构体指针" class="headerlink" title="定义结构体指针"></a>定义结构体指针</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-5.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-6.png">  </p><h3 id="通过-new-返回结构体指针"><a href="#通过-new-返回结构体指针" class="headerlink" title="通过 new 返回结构体指针"></a>通过 <code>new</code> 返回结构体指针</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-7.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-8.png"><br>通过指针：new(),不是 <code>nil</code>,空指针<br>指向了<strong>新分配的类型的内存空间</strong>，里面存该类型的0值.<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-10.png">  </p><h2 id="结构体的匿名"><a href="#结构体的匿名" class="headerlink" title="结构体的匿名"></a>结构体的匿名</h2><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-11.png">  </p><h3 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-12.png">  </p><h2 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h2><p>一个结构体可能包含一个字段，而这个字段反过来就是一个结构体。这些结构被称为嵌套结构。<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-13.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-14.png">  </p><h3 id="将结构体的地址作为字段数值-引用传递-建议使用"><a href="#将结构体的地址作为字段数值-引用传递-建议使用" class="headerlink" title="将结构体的地址作为字段数值(引用传递) [建议使用]"></a>将结构体的地址作为字段数值(引用传递) [建议使用]</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-16.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-15.png">  </p><h2 id="Golang-中的-OPP-面向对象"><a href="#Golang-中的-OPP-面向对象" class="headerlink" title="Golang 中的 OPP(面向对象)"></a>Golang 中的 OPP(面向对象)</h2><blockquote><p><code>Golang</code> 并不是面向对象的语言….但可以模拟继承性.</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-17.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-18.png">  </p><h3 id="通过结构体的嵌套模拟继承性"><a href="#通过结构体的嵌套模拟继承性" class="headerlink" title="通过结构体的嵌套模拟继承性"></a>通过结构体的嵌套模拟继承性</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-19.png"><br><code>s3.Person.name-&gt;s3.name</code><br>Student 结构体将 Person 结构体作为一个匿名字段了.<br>那么 Person 中的字段，对于 Student 来讲，就是提升字段.<br>Student 对象直接访问 Person 中的字段<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/struct-20.png">  </p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——Pointer指针</title>
    <link href="/2022/05/02/Golang-pointer-note/"/>
    <url>/2022/05/02/Golang-pointer-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Go指针"><a href="#Go指针" class="headerlink" title="Go指针"></a>Go指针</h1><p><code>*指针类型</code>: 取指针地址对应的真实值. | 定义一个指针 <code>*p1</code><br><code>&amp;值</code>: 取值的内存地址.<br><code>var p *int</code>: 定义一个指向int类型的指针</p><h2 id="指针初步"><a href="#指针初步" class="headerlink" title="指针初步"></a>指针初步</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-1.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-2.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-3.png">  </p><hr><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-7.png">  </p><h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><p>“首先是一个指针,一个数组的地址.”<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-4.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-5.png">  </p><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>“首先是一个数组,存储的数据类型是指针.”<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-6.png">  </p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>“一个指针,指向一个函数的指针.”<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-8.png">  </p><h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>“一个函数,该函数的返回值是一个指针.”<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-9.png">  </p><h3 id="普通函数的执行分析"><a href="#普通函数的执行分析" class="headerlink" title="普通函数的执行分析"></a>普通函数的执行分析</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-10.png">  </p><h3 id="指针函数的执行分析"><a href="#指针函数的执行分析" class="headerlink" title="指针函数的执行分析"></a>指针函数的执行分析</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-11.png">  </p><h2 id="指针作为参数"><a href="#指针作为参数" class="headerlink" title="指针作为参数"></a>指针作为参数</h2><h3 id="普通函数的值传递"><a href="#普通函数的值传递" class="headerlink" title="普通函数的值传递"></a>普通函数的值传递</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-12.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-13.png">  </p><h3 id="指针作为参数时的引用传递"><a href="#指针作为参数时的引用传递" class="headerlink" title="指针作为参数时的引用传递"></a>指针作为参数时的引用传递</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-14.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-15.png">  </p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-16.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/pointer-17.png">  </p><blockquote><p>切片本来就是 <strong>引用类型</strong>,<strong>不必传递指针.</strong></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;main()数值:%v 地址:%p\n&quot;</span>, s1, s1)<br>test(s1)<br>fmt.Printf(<span class="hljs-string">&quot;执行完函数main()数值:%v 地址:%p\n&quot;</span>, s1, s1)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;进入test()数值:%v 地址:%p\n&quot;</span>, slice, slice)<br><span class="hljs-comment">// 在函数内修改切片</span><br>slice[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span><br>fmt.Printf(<span class="hljs-string">&quot;离开test()数值:%v 地址:%p\n&quot;</span>, slice, slice)<br>&#125;<br></code></pre></td></tr></table></figure><p>output:<br>切片地址都是一样的,切片发生的是引用传递</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">Hello, World!<br>main()数值:[<span class="hljs-number">1 2 3 4</span>] 地址:<span class="hljs-number">0</span>xc<span class="hljs-number">000098000</span><br>进入test()数值:[<span class="hljs-number">1 2 3 4</span>] 地址:<span class="hljs-number">0</span>xc<span class="hljs-number">000098000</span><br>离开test()数值:[<span class="hljs-number">10 2 3 4</span>] 地址:<span class="hljs-number">0</span>xc<span class="hljs-number">000098000</span><br>执行完函数main()数值:[<span class="hljs-number">10 2 3 4</span>] 地址:<span class="hljs-number">0</span>xc<span class="hljs-number">000098000</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——func函数</title>
    <link href="/2022/05/01/Golang-function-note/"/>
    <url>/2022/05/01/Golang-function-note/</url>
    
    <content type="html"><![CDATA[<h1 id="go-函数"><a href="#go-函数" class="headerlink" title="go 函数."></a>go 函数.</h1><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-2.png">  </p><h2 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-1.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-3.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-4.png">  </p><h2 id="函数的参数使用"><a href="#函数的参数使用" class="headerlink" title="函数的参数使用."></a>函数的参数使用.</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-5.png">  </p><h2 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参:"></a>实参和形参:</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-6.png">  </p><h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参:"></a>函数传参:</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-7.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-8.png">  </p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数:"></a>可变参数:</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-9.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-10.png">  </p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递:"></a>参数传递:</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-13.png">  </p><h3 id="参数的值传递"><a href="#参数的值传递" class="headerlink" title="参数的值传递:"></a>参数的值传递:</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-11.png">  </p><h3 id="参数的引用传递"><a href="#参数的引用传递" class="headerlink" title="参数的引用传递:"></a>参数的引用传递:</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-12.png">  </p><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-17.png">  </p><hr><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-14.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-15.png">  </p><blockquote><p>在定义参数返回值的时候已经初始化了.</p></blockquote><h3 id="函数多返回值"><a href="#函数多返回值" class="headerlink" title="函数多返回值"></a>函数多返回值</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-16.png">  </p><h3 id="Return-语句"><a href="#Return-语句" class="headerlink" title="Return 语句"></a>Return 语句</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-18.png"><br><code>return</code>语句：词义”返回”  </p><ol><li>一个函数有返回值，那么使用return将返回值返回给调用处</li><li>同时意味着结束了函数的执行</li></ol><p><strong>注意点:</strong></p><ol><li>一个函数定义了返回值，必须使用return语句将<strong>结果返回给调用处</strong>。return后的数据必须和<strong>函数定义的一致</strong>：个数，类型，顺序。</li><li>可以使用<code>_</code>,来舍弃多余的返回值</li><li>如果一个函数定义了有返回值，那么函数中有分支，循环，那么要保证，无论执行了哪个分支，都要有<code>return</code>语句被执行到.</li><li>如果一个函数没有定义返回值，那么函数中也可以使用return,专门用于<strong>结束函数的执行</strong>。</li></ol><h2 id="函数中变量的作用域"><a href="#函数中变量的作用域" class="headerlink" title="函数中变量的作用域"></a>函数中变量的作用域</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-19.png">  </p><blockquote><p>随着函数的结束,函数内的变量自己会销毁.</p></blockquote><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-20.png">  </p><blockquote><p>全局变量 <strong>不支持简短定义的写法</strong></p></blockquote><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-21.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-22.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-23.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-24.png">  </p><h2 id="defer-延迟函数"><a href="#defer-延迟函数" class="headerlink" title="defer(延迟函数)"></a>defer(延迟函数)</h2><p><strong>defer的词义:”延迟”,”推迟”</strong><br>在go语言中,使用 <code>defer</code> 关键字来延迟一个函数或者方法的执行.  </p><ol><li>deferi函数或方法：<strong>一个函数或方法的执行被延迟了。</strong></li><li>defer的用法:<br>对象,close(),临时文件的删除.<br>文件.open()<br>defer close() 关闭文件  </li><li>语言中关于异常的处理，<br>使用 <code>panic()</code> 和 <code>recover()</code><br>panic函数用于引发恐慌，导致程序中断执行<br>recover函数用于恢复程序的执行，<code>recover()</code>语法上要求必须在 <code>defer</code> 中执行。</li><li>如果多个defer函数：</li><li>deferi函数传递参数的时候：</li></ol><h3 id="栈的结构-先进后出-后进先出"><a href="#栈的结构-先进后出-后进先出" class="headerlink" title="栈的结构(先进后出!后进先出!)"></a>栈的结构(先进后出!后进先出!)</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-25.png"><br>当一个函数有多个延迟调用时，它们被添加到一<br>个堆栈中，并Last In First Out(LIFO) <strong>先进后出!后进先出!</strong> 的顺序中执行。</p><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-26.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-27.png">  </p><h3 id="defer-注意点"><a href="#defer-注意点" class="headerlink" title="defer 注意点"></a>defer 注意点</h3><ol><li>当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行。</li><li>当执行外围函数中的return语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。</li><li>当外围函数中的代码引发运行恐慌时，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩展至调用函数。</li></ol><h2 id="函数的数据类型"><a href="#函数的数据类型" class="headerlink" title="函数的数据类型"></a>函数的数据类型</h2><p>函数的类型：<br><code>func(参数列表的数据类型)(返回值列表的数据类型)</code>  </p><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-31.png">  </p><h3 id="基本类型回顾"><a href="#基本类型回顾" class="headerlink" title="基本类型回顾"></a>基本类型回顾</h3><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-28.png">  </p><h2 id="函数的本质"><a href="#函数的本质" class="headerlink" title="函数的本质"></a>函数的本质</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-30.png">  </p><hr><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-29.png"></p><blockquote><p>“说到底,函数也是一种特殊类型的变量.”  </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-32.png">  </p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-36.png">  </p><hr><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-34.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-35.png">  </p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-41.png">  </p><hr><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-37.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-38.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-39.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-40.png">  </p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ol><li>go 语言支持函数式编程:<br> 支持将一个函数作为另一个函数的参数<br> 也支持将一个函数作为另一个函数的返回值.  </li><li>闭包(closure):  <ol><li>一个外层函数中,有内层函数,该内层函数中,会操作外层函数的<strong>局部变量</strong>(外层函数中的参数，或者外层函数中直接定义的变量),并且该外层函数的返回值就是这个内层函数.<br>这个<strong>内层函数和外层函数的局部变量</strong>，统称为<strong>闭包结构</strong>。</li><li>局部变量的<strong>生命周期</strong>会发生改变，正常的局部变量随着函数调用而创建，随着函数的结束而销毁<br>但是闭包结构中的外层函数的局部变量并不会随着外层函数的结束销毁，因为内层函数还要<strong>继续使用</strong>。</li></ol></li></ol><hr><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-43.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-42.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/func-44.png">  </p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——map映射数据结构</title>
    <link href="/2022/05/01/Golang-map-note/"/>
    <url>/2022/05/01/Golang-map-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-map-数据类型"><a href="#Go-map-数据类型" class="headerlink" title="Go map 数据类型"></a>Go map 数据类型</h1><h2 id="定义-Map-对象"><a href="#定义-Map-对象" class="headerlink" title="定义 Map 对象"></a>定义 Map 对象</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/map-1.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/20220424210757.png">  </p><h2 id="存储值获取值"><a href="#存储值获取值" class="headerlink" title="存储值获取值"></a>存储值获取值</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/map-3.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/map-4.png">  </p><h2 id="Map-的遍历"><a href="#Map-的遍历" class="headerlink" title="Map 的遍历"></a>Map 的遍历</h2><blockquote><p>使用 <code>sort</code> 包进行排序.  </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/map-6.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/map-7.png">  </p><h2 id="Map-和-Slice-结合使用"><a href="#Map-和-Slice-结合使用" class="headerlink" title="Map 和 Slice 结合使用"></a>Map 和 Slice 结合使用</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/map-8.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/map-9.png">  </p><p>原理图:<br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/mapWithSlice.png">  </p><h2 id="Map-是引用类型"><a href="#Map-是引用类型" class="headerlink" title="Map 是引用类型"></a>Map 是引用类型</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/map-12.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/map-10.png"><br><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/map-11.png">  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/WhaleFell/GolangCoding@master/notes/img/map-5.png">  </p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——变量</title>
    <link href="/2022/04/25/Golang-variable-note/"/>
    <url>/2022/04/25/Golang-variable-note/</url>
    
    <content type="html"><![CDATA[<h1 id="golang-变量"><a href="#golang-变量" class="headerlink" title="golang 变量"></a>golang 变量</h1><p>变量是计算机语言中能储存计算结果或能表示值的抽象概念。不同的变量保存的数据类型可能会不一样。  </p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>G0语言中的<strong>变量需要声明后才能使用</strong>，同一作用域内不支持重复声明。并且G0语言的<strong>变量声明后必须使用</strong>。</p><h2 id="声明变量的语法"><a href="#声明变量的语法" class="headerlink" title="声明变量的语法"></a>声明变量的语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier <span class="hljs-keyword">type</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">var:声明变量关键字</span><br><span class="hljs-comment">1dent1fier:变量名称</span><br><span class="hljs-comment">type:变量类型</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>e.g.  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span><br>fmt.Printf(<span class="hljs-string">&quot;name: %v\n&quot;</span>, name)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 批量声明</span><br><span class="hljs-keyword">var</span> (<br>name <span class="hljs-type">string</span><br>age  <span class="hljs-type">int</span><br>b    <span class="hljs-type">bool</span><br>)<br><br>name = <span class="hljs-string">&quot;hyy&quot;</span><br>age = <span class="hljs-number">14</span><br>b = <span class="hljs-literal">false</span><br><br>fmt.Printf(<span class="hljs-string">&quot;name: %v\n&quot;</span>, name)<br>fmt.Printf(<span class="hljs-string">&quot;age: %v\n&quot;</span>, age)<br>fmt.Printf(<span class="hljs-string">&quot;b: %v\n&quot;</span>, b)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h2><p>G0语言在声明变量的时候，会<strong>自动对变量对应的内存区域进行初始化操作</strong>。每个变量会被初始化成其类型的<strong>默认值</strong>，例如：整型和浮点型变量的默认值为<code>0</code>。字符串变量的默认值为空字符串<code>&quot;&quot;</code>。布尔型变量默认为<code>false</code>,切片、函数、指针变量的默认为<code>nil</code>.</p><h3 id="变量初始化语法"><a href="#变量初始化语法" class="headerlink" title="变量初始化语法"></a>变量初始化语法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 变量名 类型 = 表达式<br></code></pre></td></tr></table></figure><p>e.g.  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//变量初始化 赋初始值</span><br><span class="hljs-keyword">var</span> title <span class="hljs-type">string</span> = <span class="hljs-string">&quot;lovehyy&quot;</span><br><span class="hljs-keyword">var</span> site <span class="hljs-type">string</span> = <span class="hljs-string">&quot;http://baidu.com&quot;</span><br><span class="hljs-keyword">var</span> agge <span class="hljs-type">int</span> = <span class="hljs-number">30</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 类型推断</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;hyy&quot;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-literal">true</span><br>fmt.Printf(<span class="hljs-string">&quot;name: %v\n&quot;</span>, name)<br>fmt.Printf(<span class="hljs-string">&quot;age: %v\n&quot;</span>, age)<br>fmt.Printf(<span class="hljs-string">&quot;b: %v\n&quot;</span>, b)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="批量初始化"><a href="#批量初始化" class="headerlink" title="批量初始化"></a>批量初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//批量初始化</span><br><span class="hljs-keyword">var</span> name, age, b = <span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">true</span><br>fmt.Printf(<span class="hljs-string">&quot;name: %v\n&quot;</span>, name)<br>fmt.Printf(<span class="hljs-string">&quot;age: %v\n&quot;</span>, age)<br>fmt.Printf(<span class="hljs-string">&quot;b: %v\n&quot;</span>, b)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h2><p>在函数内部，可以使用<code>:=</code>运算符对变量进行声明和初始化。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// name := &quot;hyy&quot; 不能用于函数外部</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//短变量声明 := 不能用于函数外部</span><br>name := <span class="hljs-string">&quot;hyy&quot;</span><br>age := <span class="hljs-number">51</span><br>b := <span class="hljs-literal">true</span><br>fmt.Printf(<span class="hljs-string">&quot;name: %v\n&quot;</span>, name)<br>fmt.Printf(<span class="hljs-string">&quot;age: %v\n&quot;</span>, age)<br>fmt.Printf(<span class="hljs-string">&quot;b: %v\n&quot;</span>, b)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：这种方法只适合在函数内部，函数外面不能使用。</strong></p></blockquote><h2 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h2><p>如果我们接收到<strong>多个变量</strong>，有一些<strong>变量使用不到</strong>，可以<strong>使用下划线_表示变量名称</strong>，这种变量叫做匿名变量。e.g.  </p><ol><li>函数定义  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getNameAndAge</span><span class="hljs-params">()</span></span> (name <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hyy&quot;</span>, <span class="hljs-number">30</span><br>&#125;<br><span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string">等价于： </span><br><span class="hljs-string">`</span><span class="hljs-string">``</span><span class="hljs-keyword">go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getNameAndAge</span><span class="hljs-params">()</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hyy&quot;</span>, <span class="hljs-number">30</span><br>&#125;<br><span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string"></span><br><span class="hljs-string">2. 接收函数返回值</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span><span class="hljs-keyword">go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getNameAndAge</span><span class="hljs-params">()</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hyy&quot;</span>, <span class="hljs-number">30</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 调用函数,匿名变量,丢弃age</span><br>name, _ := getNameAndAge()<br>fmt.Printf(<span class="hljs-string">&quot;name: %v\n&quot;</span>, name)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——const常量</title>
    <link href="/2022/04/22/Golang-const-note/"/>
    <url>/2022/04/22/Golang-const-note/</url>
    
    <content type="html"><![CDATA[<h1 id="go-语言常量"><a href="#go-语言常量" class="headerlink" title="go 语言常量"></a>go 语言常量</h1><p>常量，就是在程序<strong>编译阶段</strong>就确定下来的值，而程序在<strong>运行时则无法改变该值</strong>。在G0程序中，常量可以是数值类型(包括整型、浮点型和复数类型)、布尔类型、字符串类型等。</p><h2 id="定义常量的语法"><a href="#定义常量的语法" class="headerlink" title="定义常量的语法"></a>定义常量的语法</h2><p>定义一个常量使用const关键字，语法格式如下：  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> constantName [<span class="hljs-keyword">type</span>] = value<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">const:定义常量关键字</span><br><span class="hljs-comment">constantName:常量名称</span><br><span class="hljs-comment">type:常量类型</span><br><span class="hljs-comment">value:常量的值 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> PI <span class="hljs-type">float64</span> = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">const</span> PI2 = <span class="hljs-number">3.1415</span> <span class="hljs-comment">//可以省略类型</span><br>    <span class="hljs-comment">// PI2 = 3.15 不能重新对他赋值</span><br><span class="hljs-comment">// 批量声明</span><br><span class="hljs-keyword">const</span> (<br>width  = <span class="hljs-number">100</span><br>height = <span class="hljs-number">200</span><br>)<br><br><span class="hljs-comment">//多重赋值</span><br><span class="hljs-keyword">const</span> i, j = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">const</span> a, b, c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;foo&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="iota-关键字"><a href="#iota-关键字" class="headerlink" title="iota 关键字"></a><code>iota</code> 关键字</h2><p><code>iota</code>比较特殊，可以被认为是一个可被编译器修改的常量，它默认开始值是<code>0</code>，每调用一次加<code>1</code>。遇到<code>const</code>关键字时被重置为<code>0</code>。e.g.  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// iota 关键字</span><br><span class="hljs-keyword">const</span> (<br>a1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br>a2 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//类似 i++</span><br>a3 = <span class="hljs-literal">iota</span><br>)<br><br>fmt.Printf(<span class="hljs-string">&quot;a1: %v\n&quot;</span>, a1) <span class="hljs-comment">//0</span><br>fmt.Printf(<span class="hljs-string">&quot;a2: %v\n&quot;</span>, a2) <span class="hljs-comment">//1</span><br>fmt.Printf(<span class="hljs-string">&quot;a3: %v\n&quot;</span>, a3) <span class="hljs-comment">//2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-跳过某些值"><a href="#使用-跳过某些值" class="headerlink" title="使用 _ 跳过某些值"></a>使用 <code>_</code> 跳过某些值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// iota 关键字</span><br>    <span class="hljs-comment">// 使用 `_` 跳过某些值</span><br><span class="hljs-keyword">const</span> (<br>a1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br>_         <span class="hljs-comment">//1</span><br>a3 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//2</span><br>)<br><br>fmt.Printf(<span class="hljs-string">&quot;a1: %v\n&quot;</span>, a1) <span class="hljs-comment">//0</span><br><span class="hljs-comment">// fmt.Printf(&quot;a2: %v\n&quot;, a2) //1</span><br>fmt.Printf(<span class="hljs-string">&quot;a3: %v\n&quot;</span>, a3) <span class="hljs-comment">//2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="iota-声明中间插队"><a href="#iota-声明中间插队" class="headerlink" title="iota 声明中间插队"></a><code>iota</code> 声明中间插队</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// iota 关键字</span><br>    <span class="hljs-comment">// `iota` 声明中间插队</span><br><span class="hljs-keyword">const</span> (<br>a1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br>a2 = <span class="hljs-number">100</span>         <span class="hljs-comment">//100</span><br>a3 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//1</span><br>)<br><br>fmt.Printf(<span class="hljs-string">&quot;a1: %v\n&quot;</span>, a1) <span class="hljs-comment">//0</span><br>fmt.Printf(<span class="hljs-string">&quot;a2: %v\n&quot;</span>, a2) <span class="hljs-comment">//100</span><br>fmt.Printf(<span class="hljs-string">&quot;a3: %v\n&quot;</span>, a3) <span class="hljs-comment">//1</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——数据类型</title>
    <link href="/2022/04/21/Golang-datatype-note/"/>
    <url>/2022/04/21/Golang-datatype-note/</url>
    
    <content type="html"><![CDATA[<h1 id="go-数据类型"><a href="#go-数据类型" class="headerlink" title="go 数据类型"></a>go 数据类型</h1><p>在G0编程语言中，数据类型用于<strong>声明函数和变量</strong>，数据类型的出现是为了把数据分成所需<strong>内存大小</strong>不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以<strong>充分利用内存</strong>。 </p><p>G0语言按类别有以下几种数据类型：  </p><ol><li>布尔型<br> 布尔型的值只可以是常量 <code>true</code> 或者 <code>false</code> 。一个简单的例子：<br> <code>var b bool=true</code>  </li><li>数字类型<br> 整型int 和浮点型float32、float64,Go语言支持整型和浮点型数字，并且支持复数，具中位的运算采用补码。</li><li>字符串类型<br> 字符串就是一串因定长度的字符连接起来的字符序列。G0的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本，</li><li>派生类型  <ol><li>指针类型(Pointer)</li><li>数组类型(c)</li><li>结构体类型(struct)</li><li>Channel:类型</li><li>函数类型</li><li>切片类型  </li><li>接口类型  </li><li>Map类型</li></ol></li></ol><h2 id="格式化输出类型"><a href="#格式化输出类型" class="headerlink" title="格式化输出类型"></a>格式化输出类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span> = <span class="hljs-string">&quot;tom&quot;</span><br>age := <span class="hljs-number">20</span><br>b := <span class="hljs-literal">true</span><br><span class="hljs-comment">// 格式化输出</span><br><span class="hljs-comment">// %T 类型</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, name)<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, age)<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">string<br>int<br>bool<br></code></pre></td></tr></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>go语言中的布尔类型有两个常量值：<code>true</code>和<code>false</code>。布尔类型经常用在<strong>条件判断</strong>语句，或者<strong>循环语句</strong>。也可以用在<strong>逻辑表达式</strong>中。</p><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h2 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a>派生类型</h2><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//指针类型</span><br>a := <span class="hljs-number">100</span><br>p := &amp;a <span class="hljs-comment">//取a的内存地址 p是指针类型</span><br>fmt.Printf(<span class="hljs-string">&quot;%T&quot;</span>, p) <span class="hljs-comment">//*int</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——go标识符-关键字-命名规则</title>
    <link href="/2022/04/20/Golang-id-note/"/>
    <url>/2022/04/20/Golang-id-note/</url>
    
    <content type="html"><![CDATA[<h1 id="go标识符-关键字-命名规则"><a href="#go标识符-关键字-命名规则" class="headerlink" title="go标识符-关键字-命名规则"></a>go标识符-关键字-命名规则</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符的英文是identifier,通俗的讲，就是给变量、常量、函数、方法、结构体、数组、切片、接口起名<br>字。  </p><p>标识符的组成:  </p><ol><li>标识符由数字、字母和下划线(_) 组成。<code>123abc_</code>  </li><li>只能以字母和下划线(_)开头。<code>abc123_sysVar123abc</code>    </li><li>标识符区分大小写。<code>nameName NAMET</code></li></ol><h2 id="标识符的命名"><a href="#标识符的命名" class="headerlink" title="标识符的命名"></a>标识符的命名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 正确的标识符</span><br><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> age <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> _sys <span class="hljs-type">int</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">错误的标识符</span><br><span class="hljs-comment">var 1name string</span><br><span class="hljs-comment">var &amp;age int</span><br><span class="hljs-comment">*/</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Go-关键字"><a href="#Go-关键字" class="headerlink" title="Go 关键字"></a>Go 关键字</h2><h2 id="go语言命名规范"><a href="#go语言命名规范" class="headerlink" title="go语言命名规范"></a>go语言命名规范</h2><p>Go是一门区分大小写的语言<br>命名规则涉及变量、常量、全局函数、结构、接口、方法等的命名。G0语言从语法层面进行了以下限定：任何需要对外暴露的名字必须以大写字母开头，不需要对外暴露的则应该以小写字母开头。<br>当命名(包括常量、变量、类型、函数名、结构字段等等)以一个大写字母开头，如：GetUserName,那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出(像面向对象语言中的public)；命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的(像面向对象语言中的private)  </p><h3 id="包名称"><a href="#包名称" class="headerlink" title="包名称"></a>包名称</h3><p>保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为小写单词，不要使用下划线或者混合大小写。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> dao  <br><span class="hljs-keyword">package</span> service<br></code></pre></td></tr></table></figure><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>尽量采取有意义的文件名，简短，有意义，应该为小写单词，使用下划线分隔各个单词。<code>customer_dao.go</code></p><h3 id="结构体命名"><a href="#结构体命名" class="headerlink" title="结构体命名"></a>结构体命名</h3><p>采用驼峰命名法，首字母根据访问控制大写或者小写 <code>struct</code> 申明和初始化格式采用多行，例如下面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CustomerOrder <span class="hljs-keyword">struct</span>&#123;<br>Name <span class="hljs-type">string</span><br>Address <span class="hljs-type">string</span><br>&#125;<br>order:=CustomerOrder&#123;<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-string">&quot;北京海淀&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口命名"><a href="#接口命名" class="headerlink" title="接口命名"></a>接口命名</h3><p>命名规则基本和上面的结构体类型<br>单个函数的结构名以“er”作为后缀，例如Reader,Writer.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span>&#123;<br>Read(p [] <span class="hljs-type">byte</span>)(n <span class="hljs-type">int</span>,err <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则：<br>如果变量为私有，且特有名词为首个单词，则使用小写，如appService若变量类型为bool类型，则名称应以Has,Is,Can或Allow开头  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> isExist <span class="hljs-type">bool</span><br><span class="hljs-keyword">var</span> hasConflict <span class="hljs-type">bool</span><br><span class="hljs-keyword">var</span> canManage <span class="hljs-type">bool</span><br><span class="hljs-keyword">var</span> allowGitHook <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 学习笔记——Go环境搭建</title>
    <link href="/2022/04/19/Golang-envbuild-note/"/>
    <url>/2022/04/19/Golang-envbuild-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Go环境搭建"><a href="#Go环境搭建" class="headerlink" title="Go环境搭建"></a>Go环境搭建</h1><ol><li><p>安装完Go,添加 <code>bin</code> 目录到环境变量.</p></li><li><p>CMD 配置go环境</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">go version # 输出版本<br>go env # 显示 go 环境变量<br>set GO111MODULE=on  # 包管理<br>set GOPROXY=http://goproxy.cn  # 设置镜像源<br></code></pre></td></tr></table></figure><ol start="3"><li>Vscode 安装 <code>Go</code> <code>Run code</code> 插件</li></ol><h2 id="Hello-Go"><a href="#Hello-Go" class="headerlink" title="Hello Go"></a>Hello Go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello go&quot;</span>)<br>&#125;<br><br># 运行<br><span class="hljs-keyword">go</span> run helloworld.<span class="hljs-keyword">go</span><br># 编译为可执行文件<br><span class="hljs-keyword">go</span> build hellworld.<span class="hljs-keyword">go</span><br># 下载包<br><span class="hljs-keyword">go</span> mod init go_pro  # 新建依赖<br><span class="hljs-keyword">go</span> get XXX 或 <span class="hljs-keyword">go</span> get install 源码包<br><span class="hljs-keyword">go</span> list # 列出包<br><span class="hljs-keyword">go</span> tool # 输出<span class="hljs-keyword">go</span>工具<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub Workflow 工作流使用笔记</title>
    <link href="/2022/03/29/github-workflow/"/>
    <url>/2022/03/29/github-workflow/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>GitHub</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>Workflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器备忘录✨</title>
    <link href="/2022/03/20/server-all/"/>
    <url>/2022/03/20/server-all/</url>
    
    <content type="html"><![CDATA[<h1 id="服务器备忘录"><a href="#服务器备忘录" class="headerlink" title="服务器备忘录"></a>服务器备忘录</h1><blockquote><p><strong>2022年3月19日</strong> Update.  </p></blockquote><h1 id="落落家X86"><a href="#落落家X86" class="headerlink" title="落落家X86"></a>落落家X86</h1><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><ul><li><p><strong>运行内存(RAM)：</strong>4GB（笔记本ddr3内存条）</p></li><li><p><strong>CPU：</strong>4 x Intel(R) Atom(TM) CPU D2550 @ 1.86GHz &#x2F; 512 KB cache <a href="https://www.intel.cn/content/www/cn/zh/products/sku/65470/intel-atom-processor-d2550-1m-cache-1-86-ghz/specifications.html">英特尔凌动® 处理器 D2550 (intel.cn)</a> 2核4线程</p></li><li><p><strong>服务器系统</strong>：Ubuntu 18.04 Server</p><p>Linux whalefall 4.15.0-171-generic #180-Ubuntu SMP Wed Mar 2 17:25:05 UTC 2022 x86_64</p></li><li><p><strong>硬盘：</strong><code>df -h</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Filesystem      Size  Used Avail Use% Mounted on<br>/dev/sdb2       146G   18G  122G  13% /  # 系统盘 150GB<br>/dev/sda1       299G  294G  5.0G  99% /mnt/disk  # 3.5寸硬盘1 300GB (跑wx)<br>/dev/sdc1       466G  129G  338G  28% /mnt/mainDisk  # 2.5寸硬盘2 500GB (NAS)<br></code></pre></td></tr></table></figure></li><li><p><strong>网络：</strong> <code>ifconfig</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">enp2s0:  # 主网卡 <br>        inet 192.168.5.123  netmask 255.255.255.0  broadcast 192.168.5.255<br>enp1s0:  # 副网卡<br>        inet 192.168.5.124  netmask 255.255.255.0  broadcast 192.168.5.255<br></code></pre></td></tr></table></figure><ul><li>enp2s0：主网卡，跑 <strong>qBittorrent</strong> </li><li>enp1s0：副网卡，docker network —— macnet （openwrt），网心云docker</li></ul></li></ul><h2 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><blockquote><p>配置文件：<code>/etc/nginx/conf.d</code>; <code>/etc/nginx/sites-enabled</code></p><p>默认配置：<a href="#Nginx-default-config">Nginx默认配置</a></p></blockquote><ol><li><p>Port: 80  </p><p>Desc: 运行探针服务。 </p><p>Path: <code>/var/www/html</code>  </p></li><li><p>Port: 86  </p><p>Desc: python3-cookbook 3.0.0 文档。  </p><p>Path: <code>/www/openvpn_admin/</code>  </p></li><li><p>Port: 88</p><p>Desc: 可道云 Kodcloud.</p><p>Path: <code>/www/kodcloud</code></p></li><li><p>Port: 89</p><p>Desc: AiraNg 下载器。（已反向代理Aira2 6800）<a href="#AiraNg-download-config">配置文件</a></p><p>Path: <code>/www/kodcloud</code></p></li></ol><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ol><li><p>Port：9090</p><p>Desc：Portainer web admin</p><p>command：<a href="#run-portainer-command">source</a></p></li><li><p>Port：8989</p><p>Desc：qBittorrent download</p><p>command：<a href="#run-qBittorrent-command">source</a></p></li><li><p>Port：18888</p><p>Desc：网心云（容器魔方）</p><p>command：<a href="#run-wxedge-command">source</a></p></li><li><p>network：macnet</p><p>ip：192.168.5.66</p><p>Desc：openwrt 软路由</p><p>coomand：<a href="#run-openwrt-by-docker">source</a></p></li></ol><h1 id="部分配置文件"><a href="#部分配置文件" class="headerlink" title="部分配置文件"></a>部分配置文件</h1><h2 id="Nginx-default-config"><a href="#Nginx-default-config" class="headerlink" title="Nginx_default_config"></a>Nginx_default_config</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>        listen 80 default_server;<br>        listen [::]:80 default_server;<br>        root /www/;<br>        index index.php index.html index.htm index.nginx-debian.html;<br>        server_name _;<br>        location / &#123;<br>                try_files $uri $uri/ =404;<br>        &#125;<br>        location ~ .*\.php(\/.*)*$ &#123;<br>                include snippets/fastcgi-php.conf;<br>                # With php-fpm (or other unix sockets):<br>                fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;<br>                # With php-cgi (or other tcp sockets):<br>        #       fastcgi_pass 127.0.0.1:9000;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AiraNg-download-config"><a href="#AiraNg-download-config" class="headerlink" title="AiraNg_download_config"></a>AiraNg_download_config</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">89</span> default_server;<br>        <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">89</span> default_server;<br>        <span class="hljs-attribute">root</span> /www/AiraNg/;<br>        <span class="hljs-attribute">index</span> index.php index.html index.htm index.nginx-debian.html;<br>        <span class="hljs-attribute">server_name</span> _;<br>        <span class="hljs-section">location</span> / &#123;<br>                <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ =<span class="hljs-number">404</span>;<br>        &#125;<br>        <span class="hljs-section">location</span> <span class="hljs-regexp">~ .*\.php(\/.*)*$</span> &#123;<br>                <span class="hljs-attribute">include</span> snippets/fastcgi-php.conf;<br>                <span class="hljs-comment"># With php-fpm (or other unix sockets):</span><br>                <span class="hljs-attribute">fastcgi_pass</span> unix:/var/run/php/php7.4-fpm.sock;<br>                <span class="hljs-comment"># With php-cgi (or other tcp sockets):</span><br>        <span class="hljs-comment">#       fastcgi_pass 127.0.0.1:9000;</span><br>        &#125;<br>        <span class="hljs-comment"># 反向代理 Aria ws</span><br>        <span class="hljs-section">location</span> /jsonrpc &#123;<br>        <span class="hljs-attribute">proxy_redirect</span> <span class="hljs-literal">off</span>;<br>        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:6800/jsonrpc;<br>        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$http_host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="run-qBittorrent-command"><a href="#run-qBittorrent-command" class="headerlink" title="run qBittorrent command"></a>run qBittorrent command</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行 qbittorrent docker 版</span><br> docker create \<br>    --name=qbittorrent \<br>    -e QB_WEBUI_PORT=8989 \<br>    -e QB_EE_BIN=false \<br>    -e UID=0 \<br>    -e GID=0 \<br>    -e QB_TRACKERS_UPDATE_AUTO=true \<br>    -e QB_TRACKERS_LIST_URL=https://trackerslist.com/all.txt \<br>    -e TZ=Asia/Shanghai \<br>    -e UMASK=022 \<br>    -p 6881:6881 \<br>    -p 6881:6881/udp \<br>    -p 8989:8989 \<br>    -v /root/qb_config:/config \<br>    -v /mnt/mainDisk/download/:/Downloads \<br>    --restart unless-stopped \<br>    johngong/qbittorrent:latest<br></code></pre></td></tr></table></figure><h3 id="run-portainer-command"><a href="#run-portainer-command" class="headerlink" title="run_portainer_command"></a>run_portainer_command</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行汉化版 Portainer</span><br>docker run -d -p 9000:9000 <br>--name portainer \ <br>--restart always \ <br>-v /var/run/docker.sock:/var/run/docker.sock \ <br>-v portainer_data:/data \ <br>-v /root/public:/public \ <br>portainer/portainer<br></code></pre></td></tr></table></figure><h3 id="run-wxedge-command"><a href="#run-wxedge-command" class="headerlink" title="run_wxedge_command"></a>run_wxedge_command</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=wxedge --restart=always --privileged --net=host  --tmpfs /run --tmpfs /tmp -v /mnt/disk/wxedge_storage:/storage:rw -e NIC=enp2s0  onething1/wxedge<br></code></pre></td></tr></table></figure><blockquote><p>-e NIC：指定网卡</p></blockquote><h3 id="run-openwrt-by-docker"><a href="#run-openwrt-by-docker" class="headerlink" title="run_openwrt_by_docker"></a>run_openwrt_by_docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个网络 指定网卡</span><br>docker network create -d macvlan --subnet=192.168.5.0/24 --gateway=192.168.5.1 -o parent=enp2s0 macnet<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行 openwrt 镜像 指定ip</span><br>docker run --restart always --name openwrt -d --network macnet --ip=192.168.5.66 --privileged openwrt_myself:latest<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器命令行，修改 /etc/network/config</span><br>config interface &#x27;loopback&#x27;<br>        option proto &#x27;static&#x27;<br>        option ipaddr &#x27;127.0.0.1&#x27;<br>        option netmask &#x27;255.0.0.0&#x27;<br>        option device &#x27;lo&#x27;<br><br>config interface &#x27;lan&#x27;<br>        option type &#x27;bridge&#x27;<br>        option ifname &#x27;eth0&#x27;<br>        option proto &#x27;static&#x27;<br>        option netmask &#x27;255.255.255.0&#x27;<br>        option gateway &#x27;192.168.5.1&#x27;<br>        option dns &#x27;192.168.5.1&#x27;<br>        option ipaddr &#x27;192.168.5.66&#x27;<br>        <br><span class="hljs-meta prompt_"># </span><span class="language-bash">openwrt 防火墙自定义规则添加</span><br>iptables -t nat -I POSTROUTING -o eth0 -jMASQUERADE<br></code></pre></td></tr></table></figure><h3 id="run-ttnode-by-docker"><a href="#run-ttnode-by-docker" class="headerlink" title="run_ttnode_by_docker"></a>run_ttnode_by_docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker run -d \<br>  -v /tiptime_dir:/mnt/data/ttnode \<br>  -v /var/run/docker.sock:/var/run/docker.sock \<br>  --name ttnode \<br>  --hostname ttnode \<br>  --net=host \<br>  --restart=always \<br>  tiptime/ttnode:latest<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Server</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Note</title>
    <link href="/2022/03/20/linux-note/"/>
    <url>/2022/03/20/linux-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-Notes"><a href="#Linux-Notes" class="headerlink" title="Linux Notes"></a>Linux Notes</h1><h2 id="硬盘操作"><a href="#硬盘操作" class="headerlink" title="硬盘操作"></a>硬盘操作</h2><h3 id="格式化硬盘为-ETX4-格式"><a href="#格式化硬盘为-ETX4-格式" class="headerlink" title="格式化硬盘为 ETX4 格式"></a>格式化硬盘为 ETX4 格式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfs.ext4 /dev/*** #将硬盘格式化成 ext4 格式<br></code></pre></td></tr></table></figure><h3 id="设置硬盘开机挂载"><a href="#设置硬盘开机挂载" class="headerlink" title="设置硬盘开机挂载"></a>设置硬盘开机挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.通过 lsblk 命令获取磁盘分区，并挂载磁盘到mnts目录。</span><br>lsblk<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.通过 blkid 命令获取存储设备UUID</span><br>blkid /dev/sda<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.编辑 /etc/fstab 文件，在fstab最后添加存储设备信息，实现开机自动加载</span><br>vim /etc/fstab<br>UUID=cdfc0924-7703-40f4-b6ab-8ef3f9adbf06 /mnt/disk ext4 defaults 0 0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.通过mount -a命令重新加载 /etc/fstab 内容</span><br>mount -a<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用查询硬盘命令</span><br>fdisk -l<br>df -h<br></code></pre></td></tr></table></figure><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><h3 id="开机自启动某个脚本"><a href="#开机自启动某个脚本" class="headerlink" title="开机自启动某个脚本"></a>开机自启动某个脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑 systemctl 文件</span><br>vim /etc/systemd/system/ttnode.service<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件内容</span><br>[Unit]<br>Description=Python Task Service<br>After=network.target<br><br>[Service]<br>Type=simple<br>User=root<br>Group=root<br>ExecStart=/usr/node/ttnode -p /mnt/disk/<br>Restart=always<br>RestartSec=2<br>PrivateTmp=true<br><br>[Install]<br>WantedBy=multi-user.target<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重载</span><br>systemctl daemon-reload<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动</span><br>systemctl start ttnode<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开机自启</span><br>systemctl enable ttnode<br></code></pre></td></tr></table></figure><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><h3 id="OpenVPN-配置"><a href="#OpenVPN-配置" class="headerlink" title="OpenVPN 配置"></a>OpenVPN 配置</h3><blockquote><p>参考：<a href="https://serverfault.com/questions/785767/with-openvpn-how-can-i-only-let-lan-go-through-the-vpn">窗口 - 使用OpenVPN，我如何只能让局域网通过VPN？- 服务器故障 (serverfault.com)</a> <strong>重要</strong></p><p><a href="https://www.cnblogs.com/lsgxeva/p/11378768.html">ROUTE: route addition failed - lsgxeva - 博客园 (cnblogs.com)</a></p><p><a href="https://superuser.com/questions/1608345/how-to-route-only-subnet-in-openvpn-and-not-internet-traffic">networking - How to route only subnet in OpenVPN and not internet traffic - Super User</a></p></blockquote><p>服务端：<code>server.conf</code>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">server 192.168.255.0 255.255.255.0<br>verb 3<br>key /etc/openvpn/pki/private/0.0.0.0.key<br>ca /etc/openvpn/pki/ca.crt<br>cert /etc/openvpn/pki/issued/0.0.0.0.crt<br>dh /etc/openvpn/pki/dh.pem<br>tls-auth /etc/openvpn/pki/ta.key<br>key-direction 0<br>keepalive 10 60<br>persist-key<br>persist-tun<br><br>proto tcp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Rely on Docker to <span class="hljs-keyword">do</span> port mapping, internally always 1194</span><br>port 1194<br>dev tun0<br>status /tmp/openvpn-status.log<br><br>user nobody<br>group nogroup<br>comp-lzo no<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## Route Configurations Below</span></span><br>route 192.168.254.0 225.225.225.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## Push Configurations Below</span></span><br></code></pre></td></tr></table></figure><p>客户端：<code>client.conf</code>  </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">client<br>nobind<br>dev tun<br>remote-cert-tls server<br>remote tx.cyidz.xyz 11194 tcp<br><br>&lt;key&gt;<br><span class="hljs-params">-----BEGIN</span> PRIVATE KEY<span class="hljs-params">-----</span><br><span class="hljs-string">....</span><br><span class="hljs-params">-----END</span> CERTIFICATE<span class="hljs-params">-----</span><br>&lt;<span class="hljs-string">/ca</span>&gt;<br>key-direction 1<br>&lt;tls-auth&gt;<br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 2048 bit OpenVPN static key</span><br><span class="hljs-comment">#</span><br><span class="hljs-params">-----BEGIN</span> OpenVPN Static key V1<span class="hljs-params">-----</span><br><span class="hljs-string">....</span><br><span class="hljs-params">-----END</span> OpenVPN Static key V1<span class="hljs-params">-----</span><br>&lt;<span class="hljs-string">/tls-auth</span>&gt;<br><br><span class="hljs-comment"># redirect-gateway def1  # 注释掉</span><br>dhcp-option DNS 114.114.114.114 <span class="hljs-comment"># 自定义DNS</span><br>route 192.168.1.0 255.255.255.0  <span class="hljs-comment"># 添加路由</span><br>route 192.168.0.0 255.255.255.0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩客云帮助手册</title>
    <link href="/2021/12/19/wky-help/"/>
    <url>/2021/12/19/wky-help/</url>
    
    <content type="html"><![CDATA[<h1 id="学校玩客云修复计划"><a href="#学校玩客云修复计划" class="headerlink" title="学校玩客云修复计划"></a>学校玩客云修复计划</h1><h2 id="重新烧写玩客云"><a href="#重新烧写玩客云" class="headerlink" title="重新烧写玩客云"></a>重新烧写玩客云</h2><ol><li><p>带螺丝批，拆机短接，<strong>双公 <code>USB</code></strong> 连接一体机烧写 <code>Armbian5.67直刷包带宝塔.7z</code></p></li><li><p>玩客云通过网线直连一体机，参考：<a href="https://zhuanlan.zhihu.com/p/37761024">树莓派使用网线直连电脑的方法 - 知乎 (zhihu.com)</a></p><ul><li><p>手机开热点一体机连接</p></li><li><p>Win10可以直接从【设置-&gt;网络和Internet-&gt;状态-&gt;更改适配器设置】进入可以看到，我们的本地网络连接方式有 <strong>WLAN无线连接</strong> 和 <strong>以太网有线连接</strong> 两种方式。</p></li><li><p>记录当前我们的网络连接状况：<code>arp -a</code></p></li><li><p><strong>共享WLAN网络给以太网</strong></p><p>更改适配器设置 界面中选择修改 WLAN 属性。选择共享，设置共享网络给以太网。（其他选项全部选择）</p></li><li><p><strong>查询树莓派的IP地址</strong></p><p>将树莓派的网线插到一体机的PC端口后再查询一次：<code>arp -a</code></p></li></ul></li><li><p>利用 <strong>Putty</strong> 连接玩客云。</p><p>SSH远程账号 <code>root</code>  ：密码1234<br>宝塔账号 <code>onecloud</code>  ：密码123456</p></li></ol><h2 id="玩客云配置"><a href="#玩客云配置" class="headerlink" title="玩客云配置"></a>玩客云配置</h2><ol><li><p><strong>换源</strong></p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_42877824/article/details/119332805">玩客云刷armbian更新源报错The repository ‘http://apt.armbian.com stretch Release‘ does not have a Release file</a></p></blockquote><p><strong>修改源配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /etc/apt/sources.list<br><br>deb http://mirrors.ustc.edu.cn/debian stretch main contrib non-free<br>deb http://mirrors.ustc.edu.cn/debian stretch-updates main contrib non-free<br>deb http://mirrors.ustc.edu.cn/debian stretch-backports main contrib non-free<br>deb http://mirrors.ustc.edu.cn/debian-security/ stretch/updates main contrib non-free<br><br>sudo nano /etc/apt/sources.list.d/armbian.list<br>deb [trusted=yes] http://apt.armbian.com bionic main bionic-utils bionic-desktop<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新源</span><br>sudo apt update<br>sudo apu upgrade<br></code></pre></td></tr></table></figure></li><li><p><strong>卸载自带的宝塔面板</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get install wget git nginx -y<br>wget http://download.bt.cn/install/bt-uninstall.sh<br>sh bt-uninstall.sh<br></code></pre></td></tr></table></figure></li><li><p><strong>部署 <code>Frpc</code> 内网穿透</strong></p><p><strong>下载并解压</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~<br>wget https://hub.fastgit.org/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_arm.tar.gz<br>tar -xzvf frp_0.38.0_linux_arm.tar.gz<br></code></pre></td></tr></table></figure><p><strong>拷贝配置文件：</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = frps.<span class="hljs-number">420400150</span>.xyz<br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span><br><span class="hljs-attr">token</span> = <span class="hljs-number">12345678</span><br><span class="hljs-attr">user</span> = whalefall<br><span class="hljs-attr">login_fail_exit</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">protocol</span> = tcp<br><span class="hljs-attr">tcp_mux</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">dns_server</span> = <span class="hljs-number">114.114</span>.<span class="hljs-number">114.114</span><br><span class="hljs-attr">tls_enable</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[ssh_tcp]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">22</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">42202</span><br><span class="hljs-attr">use_encryption</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">use_compression</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[pi_vpn]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">1194</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">41194</span><br><span class="hljs-attr">use_encryption</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">use_compression</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>配置 systemctl 服务并设置开机自启动</strong></p><p>systemctl 配置文件夹在 <code>/etc/systemd/system/frpc.service</code> 目录下</p><p>配置文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Frp Client Service<br><span class="hljs-attr">After</span>=network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=simple<br><span class="hljs-attr">User</span>=root<br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">5</span>s<br><span class="hljs-attr">ExecStart</span>=/root/frp/frpc -c /root/frp/frpc.ini<br><span class="hljs-attr">ExecReload</span>=/root/frp/frpc reload -c /root/frp/frpc.ini<br><span class="hljs-attr">LimitNOFILE</span>=<span class="hljs-number">1048576</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl start frpc # 开启<br>sudo systemctl status frpc  # 查看状态<br>sudo systemctl enable frpc  # 设置开机自启<br></code></pre></td></tr></table></figure></li><li><p><strong>Python</strong> 调优</p><p><strong>Python</strong> 更换国内 <code>pip</code> 源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/.pip<br>nano ~/.pip/pip.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">写入</span><br>[global]<br>timeout = 5000<br>index-url = https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple<br>[install]<br>use-mirrors = true<br>mirrors = https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple<br><br>python3 -m pip install --upgrade pip  # 更新pip<br>pip3 install httpx  # 测试<br></code></pre></td></tr></table></figure></li><li><p>部署<strong>校园网自动登录 <code>FRPC</code> 配置自动获取脚本</strong></p><blockquote><p>项目地址：<a href="https://github.com/AdminWhaleFall/rpi-ping">AdminWhaleFall&#x2F;rpi-ping: 树莓派自动上传信息工具. (github.com)</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~<br>git clone https://hub.fastgit.org/AdminWhaleFall/rpi-ping<br>chmod 777 -R rpi-ping<br><br>cd rpi-ping<br>pip3 install -r req... (Tab补全)<br>python3 main.py  # 测试运行<br></code></pre></td></tr></table></figure><p>脚本设置为 systemctl 服务：</p><p>新建 <code>/etc/systemd/system/rpi.service</code> ：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Python Task Service<br><span class="hljs-attr">After</span>=network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=simple<br><span class="hljs-attr">User</span>=root<br><span class="hljs-attr">Group</span>=root<br><span class="hljs-attr">ExecStart</span>=/usr/bin/python3 /root/rpi-ping/main.py<br><span class="hljs-attr">Restart</span>=always<br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">2</span><br><span class="hljs-attr">PrivateTmp</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure></li></ol><h2 id="玩客云网络配置（重要）"><a href="#玩客云网络配置（重要）" class="headerlink" title="玩客云网络配置（重要）"></a>玩客云网络配置（重要）</h2><ol><li><p>设置静态ip：</p><blockquote><p>我们学校的校园网没有 dhcp 服务器，要手动设置IP，教学楼的网段是：<strong>192.168.5.0&#x2F;24</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano /etc/network/interfaces<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注释掉</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">iface eth0 inet dhcp</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加静态IP</span><br>iface eth0 inet static<br>address 192.168.5.12<br>netmask 255.255.255.0<br>gateway 192.168.5.1<br>dns-nameservers 114.114.114.114 192.168.3.3<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">address: 地址；netmask: 子网掩码；gateway:路由</span><br>systemctl restart NetworkManager  # 重启网络服务<br></code></pre></td></tr></table></figure><p>然后把玩客云插到讲台下面的网线处.访问 <code>192.168.5.12</code> 测试</p></li><li><p>永久修改dns：</p><p>禁用 dhcp 分配的dns服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano /etc/dhcp/dhclient.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后添加一行</span><br>supersede domain-name-servers 114.114.114.114, 8.8.8.8;<br>dhclient<br></code></pre></td></tr></table></figure><p>在 Resolvconf 中设置永久 DNSNameservers ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano /etc/resolvconf/resolv.conf.d/head<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加</span><br>nameserver 114.114.114.114<br><br>systemctl restart resolvconf.service<br>resolvconf -u<br>sudo dpkg-reconfigure resolvconf<br><br>cat /etc/resolv.conf<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>WKY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask Web 框架学习笔记</title>
    <link href="/2021/08/18/Flask-Web-note/"/>
    <url>/2021/08/18/Flask-Web-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Flask-Web-框架学习笔记"><a href="#Flask-Web-框架学习笔记" class="headerlink" title="Flask Web 框架学习笔记"></a>Flask Web 框架学习笔记</h1><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210818152255.png"></p><h2 id="1-Flask-初始化参数"><a href="#1-Flask-初始化参数" class="headerlink" title="1. Flask 初始化参数"></a>1. Flask 初始化参数</h2><blockquote><p><strong>Flask程序实例</strong>在创建的时候，需要<strong>默认传入当前Flask程序所指定的包</strong>(模块).</p></blockquote><ul><li>import name<ul><li>Flask程序所在的包(模块),传 <code>__name__</code> 就可以</li><li>其可以决定Flask在访问静态文件时查找的路径</li></ul></li><li>static_ <em>url</em> _path<ul><li>静态文件访问路径，可以不传，默认为: &#x2F;+静态文件目录名</li></ul></li><li>static_ folder<br>-静态文件存储的文件夹，可以不传，默认为 static</li><li>template_ folder<ul><li>模板文件存储的文件夹，可以不传，默认为 templates</li></ul></li></ul><h3 id="Flask-基本编写"><a href="#Flask-基本编写" class="headerlink" title="Flask 基本编写"></a>Flask 基本编写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入Flask类</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-comment">#Flask类接收一个参数 __name__</span><br>app = Flask(__name__)<br><br><span class="hljs-comment"># 装饰器的作用是将路由映射到视图函数index</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>() :<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World&#x27;</span><br><br><span class="hljs-comment"># Flask应用程序实例的run方法启动WEB服务器</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>app.run()<br></code></pre></td></tr></table></figure><h2 id="2-Flask-工程配置加载的方式"><a href="#2-Flask-工程配置加载的方式" class="headerlink" title="2. Flask 工程配置加载的方式"></a>2. Flask 工程配置加载的方式</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>Flask将配置信息保存到了<code>app.config</code>属性中，该属性可以按照<strong>字典类型</strong>进行操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python3">app.config.get(name) # 读取<br>app.config[name] # 修改<br></code></pre></td></tr></table></figure><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><ul><li><p><strong>从配置对象中加载</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultConfig</span>(<span class="hljs-title class_ inherited__">oject</span>):<br>    <span class="hljs-comment"># 密钥</span><br>    SECRET_KET = <span class="hljs-string">&#x27;lovehyy2021209classpzezprem&#x27;</span><br>app = Flask(__name__)<br>app.config.from_object(DefaultConfig) <span class="hljs-comment"># 从配置对象中加载</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>) </span><span class="hljs-comment"># 装饰器-&gt;路由</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(): <span class="hljs-comment"># 视图函数</span><br>    <span class="hljs-built_in">print</span>(app.config[<span class="hljs-string">&#x27;SECRET_KEY&#x27;</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>从配置文件中加载</strong></p><p>在项目目录下新建<code>setting.py</code>文件，存放大写常量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">SECRET_KET = <span class="hljs-string">&#x27;lovehyy2021209classpzezprem&#x27;</span><br></code></pre></td></tr></table></figure><p>在Flask程序文件中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">app = Flask(__name__)<br>app.config.from_pyfile(<span class="hljs-string">&#x27;setting.py&#x27;</span>) <span class="hljs-comment"># 从配置文件加载</span><br></code></pre></td></tr></table></figure></li><li><p><strong>从环境变量中加载</strong></p><blockquote><p><strong>环境变量(environment variables)</strong> 一般是指在操作系统中用来指定操作系统运行环境的一些参数，如:临时文件夹位置和系统文件夹位置等。环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。</p></blockquote><p><strong>通俗的理解，环境变量就是我们设置在操作系统中，由操作系统代为保存的变量值</strong>:</p><p>在Linux系统中设置和读取环境变量的方式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export 变量名=变量值 # 设置<br>echo $变量名 # 读取<br></code></pre></td></tr></table></figure><p><strong>Flask使用环境变量加载配置的本质是通过环境变量值找到配置文件</strong>，再读取配置文件的信息，其使用方式为：<br><code>app.config.from_ envvar(&#39;环境变量名&#39;)</code></p><p><strong>环境变量的值为配置文件的绝对路径</strong>先在终端中执行如下命令：</p><p><code>export PROJECT_ _SETTING= &#39;~/ setting. py&#39;</code></p><p>再运行如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">app = Flask(__ name__)<br>app.config.from_envvar(<span class="hljs-string">&#x27;PROJECT_ SETTING&#x27;</span>, silent=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>各配置方式优缺点</strong></p><ul><li><strong>app.config.from _object(配置对象)</strong><ul><li>继承- -&gt;优点复用</li><li>敏感数据暴露缺点</li></ul></li><li><strong>app.config.from_pyfile(配置文件)</strong><ul><li>优点 –&gt; 独立文件保护敏感数据</li><li>缺点 –&gt; 不能继承文件路径固定不灵活</li></ul></li><li><strong>app.config.from_envvar(“环境变量名”)</strong><ul><li>优点 –&gt; 独立文件保护敏感数据文件路径不固定灵活</li><li>缺点 –&gt; 不方便要记得设置环境量</li></ul></li><li><strong>设置环境变量</strong><ul><li>终端export</li><li>pycharm设置</li></ul></li></ul></li></ul><h3 id="利用工厂函数设置"><a href="#利用工厂函数设置" class="headerlink" title="利用工厂函数设置"></a>利用工厂函数设置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultConfig</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    DEBUG = <span class="hljs-literal">True</span><br>    SECRET_KEY = <span class="hljs-string">&#x27;lovehyy2021pzez209class&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_flask_app</span>(<span class="hljs-params">config</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;构建flask对象的工厂函数,传入配置对象,返回配置后的app对象&#x27;&#x27;&#x27;</span><br>    app = Flask(__name__, static_url_path=<span class="hljs-string">&#x27;/static&#x27;</span>, static_folder=<span class="hljs-string">&#x27;static&#x27;</span>)<br>    app.config.from_object(config)<br>    <span class="hljs-keyword">return</span> app<br><br>app = create_flask_app(DefaultConfig)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello Flask&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__mian__&#x27;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><h2 id="3-Flask-运行方式"><a href="#3-Flask-运行方式" class="headerlink" title="3. Flask 运行方式"></a>3. Flask 运行方式</h2><h3 id="直接运行py文件启动"><a href="#直接运行py文件启动" class="headerlink" title="直接运行py文件启动"></a>直接运行py文件启动</h3><p>可以指定运行的主机IP地址，端口，是否开启调试模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">app.run(host=<span class="hljs-string">&quot;0.0.0.0&quot;</span>, port=<span class="hljs-number">5000</span>, debug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>关于<strong>DEBUG调试模式</strong>：</p><ol><li>程序代码修改后可以自动重启服务器</li><li>在服务器出现相关错误的时候可以直接将错误信息返回到前端进行展示</li></ol><h3 id="新版启动方式"><a href="#新版启动方式" class="headerlink" title="新版启动方式"></a>新版启动方式</h3><p><strong>开发服务器</strong>启动方式：<br>在1.0版本之后，Flask调整了开发服务器的启动方式，由代码编写app. run()语句调整为<strong>命令启动flask</strong></p><p>终端启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export FLASK_APP=main # 设置启动的python文件<br>flask run # 在项目文件下执行<br></code></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>环境变量 <strong>FLASK_APP</strong> 指明flask的启动实例：</p><ul><li><code>flask run -h 0.0.0.0 -p 8000</code>绑定地址端口</li><li><code>flask run --help</code> 获取帮助</li><li>生产模式与开发模式的控制<br>通过<code>FLASK_ENV</code>环境变量指明<ul><li><code>export FLASK_ ENV=production</code> 运行在生产模式，未指明则默认为此方式</li><li><code>export FLASK_ ENV=development</code> 运行在开发模式</li></ul></li></ul><h2 id="4-Flask-路由"><a href="#4-Flask-路由" class="headerlink" title="4. Flask 路由"></a>4. Flask 路由</h2><h3 id="查询路由信息"><a href="#查询路由信息" class="headerlink" title="查询路由信息"></a>查询路由信息</h3><ul><li><p>命令行方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">flask routes<br></code></pre></td></tr></table></figure></li><li><p>在应用中的<code>url_ map</code>属性中保存着整个Flask应用的<strong>路由映射信息</strong>，可以通过读取这个属性获取<strong>路由信息</strong>。</p><p><code>print(app.url_map)</code><br>如果想在程序中遍历路由信息，可以采用如下方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">  <span class="hljs-keyword">for</span> rule <span class="hljs-keyword">in</span> app.url_map.iter_rules():<br>      <span class="hljs-comment"># endpoint 视图函数的名字</span><br>      <span class="hljs-comment"># rule 路由的路径</span><br>  <span class="hljs-built_in">print</span>( <span class="hljs-string">&#x27;name=&#123;&#125; path=&#123;&#125;&#x27;</span>. <span class="hljs-built_in">format</span>(rule.endpoint, rule.rule))<br><br>- 搭建一个**返回所有路由信息**的json接口<br><br>  ```python<br><span class="hljs-meta">  @app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>      <span class="hljs-comment"># for rule in app.url_map.iter_rules():</span><br>      <span class="hljs-comment">#     print(f&quot;name=&#123;rule.endpoint&#125;;path=&#123;rule.rule&#125;&quot;)</span><br>      rules_iterator = app.url_map.iter_rules()<br>      <span class="hljs-comment"># 字典推导式</span><br>      dic = &#123;<br>          rule.endpoint: rule.rule<br>          <span class="hljs-keyword">for</span> rule <span class="hljs-keyword">in</span> rules_iterator<br>      &#125;<br>      <span class="hljs-comment"># 利用jsonify返回json数据</span><br>      <span class="hljs-keyword">return</span> jsonify(dic)<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-路由-options-限定请求方式-methods"><a href="#5-路由-options-限定请求方式-methods" class="headerlink" title="5. 路由 options 限定请求方式 methods"></a>5. 路由 options 限定请求方式 methods</h2><h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><ul><li><p><strong>GET</strong>(自带)</p></li><li><p><strong>OPTIONS</strong>(自带)  -&gt; 简化版的GET请求用于询问服务器接口信息的<br>比如接口允许的请求方式允许的</p><blockquote><p>CORS跨域:<br><a href="http://www.meiduo.site/">www.meiduo.site</a> -&gt; api.meiduo.site&#x2F;users&#x2F;1<br>options api.meiduo.site&#x2F;uses&#x2F;1</p></blockquote></li><li><p><strong>HEAD</strong>(自带) -&gt; 简化版的GET请求</p><blockquote><p>只返回GET请求处理时的响应头，不返回响应体。</p></blockquote></li></ul><h3 id="指定接口请求方式"><a href="#指定接口请求方式" class="headerlink" title="指定接口请求方式"></a>指定接口请求方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 利用修饰器中的methods返回设定请求接口方式</span><br><span class="hljs-comment"># 定义视图</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, methods=[<span class="hljs-string">&quot;POST&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;POST API&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="6-蓝图"><a href="#6-蓝图" class="headerlink" title="6. 蓝图"></a>6. 蓝图</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在一个<strong>Flask应用项目</strong>中，如果<strong>业务视图</strong>过多，可以用某种方式划分出的<strong>业务单元单独维护</strong>，将每个单元用到的<strong>视图、静态文件、模板文件</strong>等独立分开。</p><p>例如从<strong>业务角度</strong>上，可将整个应用划分为<strong>用户模块单元、商品模块单元、订单模块单元</strong>，分别开发这些不同单元，并最终整合到一个项目应用中。</p><h3 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h3><p>在Flask中，使用<strong>蓝图Blueprint</strong>来分模块组织管理。</p><p>蓝图实际可以理解为是<strong>一个存储一组视图方法的容器对象</strong>，其具有如下特点:</p><ul><li>一个应用可以具有<strong>多个Blueprint</strong></li><li>可以将一个<strong>Blueprint注册到</strong>任何一个未使用的<strong>URL</strong>下，比如“&#x2F;user”、 “&#x2F;godds”。</li><li><strong>Blueprint</strong>可以单独具有<strong>自己的模板、静态文件</strong>或者其它的通用操作方法，它并不是必须要实现应用的视图和函数的</li><li>在一个<strong>应用初始化</strong>时，就应该要<strong>注册需要使用的Blueprint</strong>。★</li><li>但是一个<strong>Blueprint</strong>并不是一个完整的应用，它<strong>不能独立于应用运行</strong>，而必须要<strong>注册到某一个应用中</strong>。★</li></ul><h3 id="定义蓝图"><a href="#定义蓝图" class="headerlink" title="定义蓝图"></a>定义蓝图</h3><ol><li><p>定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">user_bp = Blueprint(<span class="hljs-string">&#x27;user&#x27;</span>, __name__)<br></code></pre></td></tr></table></figure></li><li><p>在这个<strong>蓝图对象上进行操作</strong>,<strong>注册路由</strong>,<strong>指定静态文件夹</strong>,<strong>注册模版过滤器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@user_bp.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_profile</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;user_profile&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>在应用对象中注册这个蓝图对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">app.register_blueprint(user_bp)<br></code></pre></td></tr></table></figure></li></ol><h3 id="单文件蓝图"><a href="#单文件蓝图" class="headerlink" title="单文件蓝图"></a>单文件蓝图</h3><p>可以将创建蓝图对象与定义视图函数放在一个文件中。</p><h3 id="目录（包）蓝图"><a href="#目录（包）蓝图" class="headerlink" title="目录（包）蓝图"></a>目录（包）蓝图</h3><p>对于一个打算包含<strong>多个文件的蓝图</strong>，通常将<strong>创建蓝图对象</strong>放到Python包的<code>__init__.py</code> 文件中</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-params">---------</span> project <span class="hljs-comment"># 工程目录</span><br>|<span class="hljs-params">----</span> main.py <span class="hljs-comment"># 启动文件</span><br>|<span class="hljs-params">----</span> user <span class="hljs-comment"># 用户蓝图</span><br>||<span class="hljs-params">----</span> __init__.py <span class="hljs-comment"># 此处创建蓝图对象</span><br>||<span class="hljs-params">----</span> views.py<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210725224412.png" alt="蓝图包目录实例"></p><h4 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h4><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210725224744.png" alt="循环引用问题"></p><blockquote><p>所以导入视图函数要放在 <code>__init__.py</code> 文件的最后</p></blockquote><h3 id="蓝图内部静态文件"><a href="#蓝图内部静态文件" class="headerlink" title="蓝图内部静态文件"></a>蓝图内部静态文件</h3><p>和<strong>应用对象</strong>不同，蓝图对象创建时<strong>不会默认注册静态目录的路由</strong>。需要我们在创建时指定<code>static_folder</code>参数。</p><p>下面的示例将蓝图所在目录下的<code>static_admin</code>目录设置为静态目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">admin = Blueprint (<span class="hljs-string">&quot;admin&quot;</span>,__ name__ , static_folder=<span class="hljs-string">&#x27;static_admin&#x27;</span>)<br>app.register_blueprint (admin, url_prefix=<span class="hljs-string">&#x27;/admin&#x27;</span> )<br></code></pre></td></tr></table></figure><p>现在就可以使用<code>/admin/static_admin/&lt;filename&gt;</code>访问<code>static_ admin</code>目录下的静态文件了。<br>也可通过<code>static_url_path</code>改变访问路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">admin = Blueprint(<span class="hljs-string">&quot;admin&quot;</span>,__name__, static_folder=<span class="hljs-string">&#x27;static_admin&#x27;</span> ,static_url_path=<span class="hljs-string">&#x27;/lib&#x27;</span>)<br>app.register_blueprint(admin, url_prefix=<span class="hljs-string">&#x27;/admin&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="7-处理请求"><a href="#7-处理请求" class="headerlink" title="7. 处理请求"></a>7. 处理请求</h2><blockquote><p>在视图编写中需要读取客户端请求携带的数据时，如何才能正确的<strong>取出数据</strong>呢?<br><strong>请求携带的数据</strong>可能出现在HTTP报文中的不同位置，需要<strong>使用不同的方法来获取参数</strong>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python asyncio 异步协程百万并发</title>
    <link href="/2021/08/18/Pytho-async/"/>
    <url>/2021/08/18/Pytho-async/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-asyncio-异步协程百万并发"><a href="#Python-asyncio-异步协程百万并发" class="headerlink" title="Python asyncio 异步协程百万并发"></a>Python asyncio 异步协程百万并发</h1><h2 id="协程（coroutine）"><a href="#协程（coroutine）" class="headerlink" title="协程（coroutine）"></a><strong>协程（coroutine）</strong></h2><blockquote><p>本质就是一个<strong>函数</strong></p></blockquote><h2 id="事件循环——-event-loop"><a href="#事件循环——-event-loop" class="headerlink" title="事件循环——(event_loop)"></a><strong>事件循环</strong>——(event_loop)</h2><p><strong>协程函数</strong>，不是像普通函数那样直接调用运行的，必须<strong>添加到事件循环</strong>中，然后由<strong>事件循环</strong>去运行，单独运行协程函数是不会有结果的，看一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_after_time</span>(<span class="hljs-params">delay,what</span>):<br>        <span class="hljs-keyword">await</span> asyncio.sleep(delay)<br>        <span class="hljs-built_in">print</span>(what)<br> <br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始时间为： <span class="hljs-subst">&#123;time.time()&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">await</span> say_after_time(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;hello&quot;</span>)<br>        <span class="hljs-keyword">await</span> say_after_time(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;world&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结束时间为： <span class="hljs-subst">&#123;time.time()&#125;</span>&quot;</span>)<br> <br>loop=asyncio.get_event_loop()    <span class="hljs-comment">#创建事件循环对象</span><br><span class="hljs-comment"># loop=asyncio.new_event_loop()   #与上面等价，创建新的事件循环</span><br>loop.run_until_complete(main())  <span class="hljs-comment">#通过事件循环对象运行协程函数</span><br>loop.close()<br></code></pre></td></tr></table></figure><p>在python3.6版本中，如果我们单独像执行普通函数那样执行一个协程函数，只会返回一个coroutine对象（python3.7）如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>main()<br>&lt;coroutine <span class="hljs-built_in">object</span> main at <span class="hljs-number">0x1053bb7c8</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="获取事件循环对象的几种方式"><a href="#获取事件循环对象的几种方式" class="headerlink" title="获取事件循环对象的几种方式"></a>获取事件循环对象的几种方式</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">loop</span> <span class="hljs-operator">=</span> asyncio.get_event_loop()<br></code></pre></td></tr></table></figure><p>它是python3.7中新添加的，<strong>获得一个事件循环</strong>，如果当前线程<strong>还没有事件循环</strong>，则<strong>创建一个新的事件循环loop；</strong></p><h3 id="通过事件循环运行协程函数的两种方式"><a href="#通过事件循环运行协程函数的两种方式" class="headerlink" title="通过事件循环运行协程函数的两种方式"></a>通过事件循环运行协程函数的两种方式</h3><ol><li><p>创建事件循环对象loop，即<code>asyncio.get_event_loop()</code>，<strong>通过事件循环运行协程函数</strong>.</p></li><li><p>直接通过<code>asyncio.run(function_name)</code>运行<strong>协程函数。</strong></p><blockquote><p><strong>但是需要注意的是，首先run函数是python3.7版本新添加的，前面的版本是没有的；</strong></p></blockquote><p> 其次，这个run函数总是<strong>会创建一个新的事件循环并在run结束之后关闭事件循环</strong>，所以，如果在<strong>同一个线程</strong>中已经有了一个事件循环，则<strong>不能再使用这个函数</strong>了，因为<strong>同一个线程不能有两个事件循环</strong>，而且这个run函数<strong>不能同时运行两次</strong>，因为他已经创建一个了。即<strong>同一个线程中是不允许有多个事件循环loop的</strong>。</p></li></ol><h2 id="Task任务"><a href="#Task任务" class="headerlink" title="Task任务"></a>Task任务</h2><h3 id="创建任务（两种方法）"><a href="#创建任务（两种方法）" class="headerlink" title="创建任务（两种方法）"></a>创建任务（两种方法）</h3><ol><li><p><code>task = asyncio.create_task(coro())</code></p><blockquote><p><strong>这是3.7版本新添加的</strong>,<strong>可以传协程函数</strong></p></blockquote></li><li><p><code>task = asyncio.ensure_future(coro())</code></p></li><li><p>也可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">loop.create_future()<br>loop.create_task(coro)<br></code></pre></td></tr></table></figure></li></ol><h3 id="获取某一个任务的方法"><a href="#获取某一个任务的方法" class="headerlink" title="获取某一个任务的方法"></a>获取某一个任务的方法</h3><ol><li><p><code>task=asyncio.current_task(loop=None)</code></p><blockquote><p>返回在某一个指定的loop中，<strong>当前正在运行的任务</strong>，<strong>如果没有任务正在运行，则返回None</strong>；<br>如果loop为None，<strong>则默认为在当前的事件循环中获取</strong>.</p></blockquote></li><li><p><code>asyncio.all_tasks(loop=None)</code></p><blockquote><p>返回某一个<strong>loop中还没有结束的任务</strong></p></blockquote></li></ol><h2 id="异步函数的结果获取"><a href="#异步函数的结果获取" class="headerlink" title="异步函数的结果获取"></a>异步函数的结果获取</h2><p>对于异步编程、异步函数而言，最重要的就是<strong>异步函数调用结束之后，获取异步函数的返回值</strong>，我们可以有以下几种方式<strong>来获取函数的返回值</strong>，第一是直接通过<code>Task.result()</code>来获取；第二种是<strong>绑定一个回调函数</strong>来获取，<strong>即函数执行完毕后调用一个函数来获取异步函数的返回值。</strong></p><ol><li><p>直接通过<code>result</code>来获取.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br> <br> <br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello1</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello world 01 begin&quot;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)  <span class="hljs-comment">#模拟耗时任务3秒</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello again 01 end&quot;</span>)<br>    <span class="hljs-keyword">return</span> a+b<br> <br>coroutine=hello1(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>)<br>loop = asyncio.get_event_loop()                <span class="hljs-comment">#第一步：创建事件循环</span><br>task = asyncio.ensure_future(coroutine)         <span class="hljs-comment">#第二步:将多个协程函数包装成任务列表</span><br>loop.run_until_complete(task)                  <span class="hljs-comment">#第三步：通过事件循环运行</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-------------------------------------&#x27;</span>)<br><span class="hljs-built_in">print</span>(task.result())<br>loop.close() <br> <br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为</span><br><span class="hljs-string">Hello world 01 begin</span><br><span class="hljs-string">Hello again 01 end</span><br><span class="hljs-string">-------------------------------------</span><br><span class="hljs-string">15</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>通过定义<strong>回调函数</strong>来获取</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br>   <br>  <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello1</span>(<span class="hljs-params">a,b</span>):<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello world 01 begin&quot;</span>)<br>      <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)  <span class="hljs-comment">#模拟耗时任务3秒</span><br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello again 01 end&quot;</span>)<br>    <span class="hljs-keyword">return</span> a+b<br>   <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">future</span>):   <span class="hljs-comment">#定义的回调函数,需要传future参数</span><br>    <span class="hljs-built_in">print</span>(future.result())<br> <br>loop = asyncio.get_event_loop()                <span class="hljs-comment">#第一步：创建事件循环</span><br>task=asyncio.ensure_future(hello1(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>))       <span class="hljs-comment">#第二步:将多个协程函数包装成任务</span><br>task.add_done_callback(callback)                      <span class="hljs-comment">#并被任务绑定一个回调函数，默认传入结果参数</span><br> <br>loop.run_until_complete(task)                  <span class="hljs-comment">#第三步：通过事件循环运行</span><br>loop.close()                                   <span class="hljs-comment">#第四步：关闭事件循环</span><br> <br> <br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">Hello world 01 begin</span><br><span class="hljs-string">Hello again 01 end</span><br><span class="hljs-string">15</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>所谓的<strong>回调函数</strong>，就是指协程函数coroutine<strong>执行结束时候会调用回调函数</strong>。并通过<strong>参数future获取协程执行的结果</strong>。我们创建的<strong>task和回调里的future对象</strong>，实际上是<strong>同一个对象</strong>，因为task是future的子类。</p></blockquote></li></ol><h2 id="asyncio异步编程的基本模板"><a href="#asyncio异步编程的基本模板" class="headerlink" title="asyncio异步编程的基本模板"></a>asyncio异步编程的基本模板</h2><h3 id="第一步：构造事件循环"><a href="#第一步：构造事件循环" class="headerlink" title="第一步：构造事件循环"></a><strong>第一步：构造事件循环</strong></h3><ol><li><p><code>loop = asyncio.get_running_loop()</code></p><blockquote><p>返回（获取）在当前线程中<strong>正在运行的事件循环</strong>，如果没有正在运行的事件循环，则会显示错误；它是<strong>python3.7中新添加的</strong></p></blockquote></li><li><p><code>loop = asyncio.get_event_loop() </code></p><blockquote><p><strong>获得一个事件循环</strong>，如果当前线程还没有事件循环，则<strong>创建一个新的事件循环loop</strong>；</p></blockquote></li><li><p><code>loop=asyncio.set_event_loop(thread) </code></p><blockquote><p>设置一个事件循环<strong>为当前线程的事件循环</strong>；</p></blockquote></li><li><p><code>loop=asyncio.new_event_loop()</code></p><blockquote><p><strong>创建一个新的事件循环</strong></p></blockquote></li></ol><h3 id="第二步：将一个或者是多个协程函数包装成任务Task"><a href="#第二步：将一个或者是多个协程函数包装成任务Task" class="headerlink" title="第二步：将一个或者是多个协程函数包装成任务Task"></a><strong>第二步：将一个或者是多个协程函数包装成任务Task</strong></h3><ol><li><p><code>task = asyncio.create_task(coro(参数列表))</code> </p><blockquote><p><strong>这是3.7版本新添加的</strong></p></blockquote></li><li><p><code>task = asyncio.ensure_future(coro(参数列表))</code></p></li></ol><blockquote><p>需要注意的是，在使用<code>Task.result()</code>获取<strong>协程函数结果</strong>的时候，使用<code>asyncio.create_task()</code>却会显示错，但是使用<code>asyncio.ensure_future</code>却正确</p></blockquote><h3 id="第三步：通过事件循环运行"><a href="#第三步：通过事件循环运行" class="headerlink" title="第三步：通过事件循环运行"></a><strong>第三步：通过事件循环运行</strong></h3><ol><li><p><code>loop.run_until_complete(asyncio.wait(tasks))</code></p><blockquote><p>通过<code>asyncio.wait()</code><strong>整合多个task</strong></p></blockquote></li><li><p><code>loop.run_until_complete(asyncio.gather(tasks))</code></p><blockquote><p>通过<code>asyncio.gather()</code><strong>整合多个task</strong></p></blockquote></li><li><p><code>loop.run_until_complete(task_1)  </code></p><blockquote><p><strong>单个任务则不需要整合</strong></p></blockquote></li><li><p><del>loop.run_forever()</del></p><blockquote><p><del>但是这个方法在新版本已经取消，不再推荐使用，因为使用起来不简洁</del></p></blockquote></li></ol><h4 id="使用gather和wait整合task注册多个服务"><a href="#使用gather和wait整合task注册多个服务" class="headerlink" title="使用gather和wait整合task注册多个服务"></a>使用<code>gather</code>和<code>wait</code>整合task注册多个服务</h4><ol><li><h4 id="参数形式不一样"><a href="#参数形式不一样" class="headerlink" title="参数形式不一样"></a><strong>参数形式不一样</strong></h4><p> <strong>gather</strong>的参数为 coroutines_or_futures,即如这种形式：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tasks = asyncio.gather(*[task1,task2,task3])<br>tasks = asyncio.gather(task1,task2,task3)<br>loop.run_until_complete(tasks)<br></code></pre></td></tr></table></figure><p><strong>wait</strong>的参数为<strong>列表或者集合</strong>的形式，如下:</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tasks = asyncio.wait([task1,task2,task3])<br>loop.run_until_complete(tasks)<br></code></pre></td></tr></table></figure></li><li><h4 id="返回的值不一样"><a href="#返回的值不一样" class="headerlink" title="返回的值不一样"></a><strong>返回的值不一样</strong></h4><p><strong>gather返回的是每一个任务运行的结果</strong>：</p><blockquote><h6 id="要以传入一个列表可变参数"><a href="#要以传入一个列表可变参数" class="headerlink" title="要以传入一个列表可变参数"></a>要以传入一个列表可变参数</h6></blockquote><p><strong>可变参数允许在调用参数的时候传入多个参数,这些参数在调用时被自动组装为一个tuple</strong></p><p><code>results = await asyncio.gather(*[tasks])</code> </p><p><code>results = await asyncio.gather(task1,task2,task3)</code> </p><p><strong>wait返回dones是已经完成的任务，pending是未完成的任务，都是集合类型</strong>：<br><code>done, pending = yield from asyncio.wait(fs)</code></p></li></ol><blockquote><p>简单来说：<strong>async.wait会返回两个值:done和pending</strong>，done为已完成的协程Task，pending为超时未完成的协程Task，<strong>需通过future.result调用Task的result。</strong></p><p>而<code>async.gather</code>返回的是<strong>已完成Task的result</strong>。</p></blockquote><h3 id="第四步：关闭事件循环"><a href="#第四步：关闭事件循环" class="headerlink" title="第四步：关闭事件循环"></a><strong>第四步：关闭事件循环</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">loop.close()<br><span class="hljs-comment"># 以上示例都没有调用 loop.close，好像也没有什么问题。所以到底要不要调 loop.close 呢？</span><br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="协程阻塞问题"><a href="#协程阻塞问题" class="headerlink" title="协程阻塞问题"></a>协程阻塞问题</h3><p><strong>异步方式依然会有阻塞的</strong>，当我们定义的很多个异步方法<strong>彼此之间有一来</strong>的时候，比如，我必须要等到函数1执行完毕，<strong>函数2需要用到函数1的返回值</strong>，就会造成<strong>阻塞</strong>，这也是异步编程的难点之一，如何合理配置这些资源，尽量<strong>减少函数之间的明确依赖</strong>，这是很重要的。</p><p><strong>结论</strong>：在有<strong>很多个异步方式</strong>的时候，一定要尽量避免这种<strong>异步函数的直接调用</strong>，这和同步是没什么区别的，一定要<strong>通过事件循环loop</strong>，<strong>“让事件循环在各个异步函数之间不停游走”</strong>，这样才不会造成阻塞。</p><h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><h3 id="使用gather同时注册多个任务，实现并发"><a href="#使用gather同时注册多个任务，实现并发" class="headerlink" title="使用gather同时注册多个任务，实现并发"></a>使用gather同时注册多个任务，实现并发</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello1</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello world 01 begin&quot;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)  <span class="hljs-comment">#模拟耗时任务3秒</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello again 01 end&quot;</span>)<br>    <span class="hljs-keyword">return</span> a+b<br> <br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello2</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello world 02 begin&quot;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)   <span class="hljs-comment">#模拟耗时任务2秒</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello again 02 end&quot;</span>)<br>    <span class="hljs-keyword">return</span> a-b<br> <br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello3</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello world 03 begin&quot;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">4</span>)   <span class="hljs-comment">#模拟耗时任务4秒</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello again 03 end&quot;</span>)<br>    <span class="hljs-keyword">return</span> a*b<br> <br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():  <span class="hljs-comment">#封装多任务的入口函数</span><br>    <span class="hljs-comment"># 用列表表达式创建任务</span><br>    tasks = [<br>        asyncio.ensure_future(hello1(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br>    ]<br>    results = <span class="hljs-keyword">await</span> asyncio.gather(tasks)   <br>    <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:    <span class="hljs-comment">#通过迭代获取函数的结果，每一个元素就是相对应的任务的返回值，顺序都没变</span><br>        <span class="hljs-built_in">print</span>(result)<br> <br> <br>loop = asyncio.get_event_loop()               <br>loop.run_until_complete(main())<br>loop.close()<br></code></pre></td></tr></table></figure><h3 id="异步-多线程"><a href="#异步-多线程" class="headerlink" title="异步+多线程"></a>异步+多线程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio <br><span class="hljs-keyword">import</span> asyncio,time,threading<br> <br><span class="hljs-comment">#需要执行的耗时异步任务</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;准备调用func,大约耗时<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(num)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;耗时<span class="hljs-subst">&#123;num&#125;</span>之后,func函数运行结束&#x27;</span>)<br> <br><span class="hljs-comment">#定义一个专门创建事件循环loop的函数，在另一个线程中启动它</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start_loop</span>(<span class="hljs-params">loop</span>):<br>    asyncio.set_event_loop(loop)<br>    loop.run_forever()<br> <br><span class="hljs-comment">#定义一个main函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    coroutine1 = func(<span class="hljs-number">3</span>)<br>    coroutine2 = func(<span class="hljs-number">2</span>)<br>    coroutine3 = func(<span class="hljs-number">1</span>)<br> <br>    new_loop = asyncio.new_event_loop()                        <span class="hljs-comment">#在当前线程下创建时间循环，（未启用），在start_loop里面启动它</span><br>    t = threading.Thread(target=start_loop,args=(new_loop,))   <span class="hljs-comment">#通过当前线程开启新的线程去启动事件循环</span><br>    t.start()<br> <br>    asyncio.run_coroutine_threadsafe(coroutine1,new_loop)  <span class="hljs-comment">#这几个是关键，代表在新线程中事件循环不断“游走”执行</span><br>    asyncio.run_coroutine_threadsafe(coroutine2,new_loop)<br>    asyncio.run_coroutine_threadsafe(coroutine3,new_loop)<br> <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;iloveu&quot;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;    &quot;</span>)<br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br> <br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">i    准备调用func,大约耗时3</span><br><span class="hljs-string">l    准备调用func,大约耗时2</span><br><span class="hljs-string">o    准备调用func,大约耗时1</span><br><span class="hljs-string">v</span><br><span class="hljs-string">e</span><br><span class="hljs-string">u</span><br><span class="hljs-string">耗时1之后,func函数运行结束</span><br><span class="hljs-string">耗时2之后,func函数运行结束</span><br><span class="hljs-string">耗时3之后,func函数运行结束</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="httpx-aiohttp-之异步请求"><a href="#httpx-aiohttp-之异步请求" class="headerlink" title="httpx aiohttp 之异步请求"></a>httpx aiohttp 之异步请求</h3><ul><li><strong>aiohttp实现</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> asyncio<br> <br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> client:<br>         <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> client.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>              <span class="hljs-keyword">assert</span> resp.status == <span class="hljs-number">200</span><br>              html= <span class="hljs-keyword">await</span> resp.text()<br>              <span class="hljs-built_in">print</span>(html)<br></code></pre></td></tr></table></figure><ul><li><strong>httpx实现</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> httpx.AsyncClient() <span class="hljs-keyword">as</span> client:<br>    resp = <span class="hljs-keyword">await</span> client.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> resp.status_code == <span class="hljs-number">200</span><br>    html = resp.text<br></code></pre></td></tr></table></figure><p>感觉总体上比较<code>aiohttp</code>写起来舒服多了<strong>，少写很多异步代码。</strong></p><blockquote><p>之前使用 aiohttp 中的 resp.status 来获取状态码的时候写了status_code，应该是使用 requests 习惯了吧，这下好了使用 httpx 不用担心这个写错的问题了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 迭代器生成器修饰器</title>
    <link href="/2021/08/18/Python-Generator-Iterator-decorater/"/>
    <url>/2021/08/18/Python-Generator-Iterator-decorater/</url>
    
    <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote><p><strong>迭代器</strong>指的是迭代取值的工具，迭代是一个重复的过程，并且每次重复都是基于上一次的结果而继续的，</p><p>单纯的重复并不是迭代!</p></blockquote><ol><li><p>可迭代对象</p><p>元组;列表;字典;集合;字符串等</p><p>生成器.</p></li><li><p>用 for 循环迭代</p></li><li><p>验证一个东西是否可迭代</p><blockquote><p><strong>可迭代不一定是迭代对象</strong></p><p>(列表不是可迭代对象,但是可迭代.)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-comment"># 判断是否是可迭代对象(迭代器)</span><br><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&quot;adb&quot;</span>,Iterable) <span class="hljs-comment"># instance:实例</span><br></code></pre></td></tr></table></figure></li><li><p>生成器可迭代,但可以迭代的不一定是生成器</p></li><li><p><code>iter()</code> 可以将列表变成可迭代对象</p></li></ol><h3 id="迭代器的作用"><a href="#迭代器的作用" class="headerlink" title="迭代器的作用"></a>迭代器的作用</h3><p>迭代器是用来<strong>迭代取值</strong>的工具，而涉及到把多个值循环取出来的类型</p><blockquote><p>有：列表、字符串、元组、字典、集合、打开文件 </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">l = [<span class="hljs-string">&#x27;egon&#x27;</span>, <span class="hljs-string">&#x27;liu&#x27;</span>, <span class="hljs-string">&#x27;alex&#x27;</span>]<br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(l):<br>    <span class="hljs-built_in">print</span>(l[i])<br>    i += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>上述<strong>迭代取值的方式</strong>只适用于<strong>有索引</strong>的数据类型：<strong>列表、字符串、元组.</strong><br>为了解决基于索引迭代器取值的局限性<br>python必须提供一种能够不<strong>依赖于索引的取值方式</strong>，这就是<strong>迭代器</strong>.</p><h3 id="迭代器详解"><a href="#迭代器详解" class="headerlink" title="迭代器详解"></a>迭代器详解</h3><p>但凡内置有<code>__iter__()</code>方法的对象都称之为<strong>可迭代的对象</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">s1=<span class="hljs-string">&#x27;&#x27;</span><br>s1.__iter__()<br><br>l=[]<br>l.__iter__()<br><br>t=(<span class="hljs-number">1</span>,)<br>t.__iter__()<br><br>d=&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>&#125;<br>d.__iter__()<br><br>set1=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>set1.__iter__()<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.txt&#x27;</span>,mode=<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.__iter__()<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><strong>迭代器对象</strong>:</p><p>内置有<code>__next__</code>方法并且内置有<code>__iter__</code>方法的对象<br>迭代器对象<code>__next()__</code>：得到迭代器的下一个值.<br>迭代器对象<code>__iter__()</code>：得到迭代器的本身，调用和没调用相同.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python">d=&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br>d_iterator=d.__iter__()<br><span class="hljs-built_in">print</span>(d_iterator)<span class="hljs-comment"># &lt;dict_keyiterator object at 0x0000022FF0E13A90&gt;</span><br><br><span class="hljs-built_in">print</span>(d_iterator.__next__())<span class="hljs-comment"># a</span><br><span class="hljs-built_in">print</span>(d_iterator.__next__())<span class="hljs-comment"># b</span><br><span class="hljs-built_in">print</span>(d_iterator.__next__())<span class="hljs-comment"># c</span><br><span class="hljs-built_in">print</span>(d_iterator.__next__())<span class="hljs-comment"># 抛出异常StopIteration,值取完了</span><br>d=&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br>d_iterator=d.__iter__()<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(d_iterator.__next__())<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-comment"># 得到&quot;a&quot;,&quot;b&quot;,&quot;c&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;====&gt;&gt;&gt;&gt;&gt;&gt;&#x27;</span>) <span class="hljs-comment"># 在一个迭代器取值取完后，再对其取值就会报错</span><br>d_iterator=d.__iter__()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(d_iterator.__next__())<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-comment"># 什么都得不到,因为迭代器值已取完</span><br><br><br>l=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>l_iterator=l.__iter__()<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(l_iterator.__next__())<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-comment"># 得到1,2,3,4,5</span><br></code></pre></td></tr></table></figure><p>常见<strong>数据类型</strong>的分类:</p><blockquote><p>可迭代对象：<strong>字符串、列表、元组、字典、集合、文件对象</strong><br>迭代器对象：<strong>文件对象</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">s1=<span class="hljs-string">&#x27;&#x27;</span><br>s1.__iter__()<br><br>l=[]<br>l.__iter__()<br><br>t=(<span class="hljs-number">1</span>,)<br>t.__iter__()<br><br><br>d=&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>&#125;<br>d.__iter__()<br><br>set1=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>set1.__iter__()<br><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.txt&#x27;</span>,mode=<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.__iter__()<br>    f.__next__()<br></code></pre></td></tr></table></figure><h3 id="创建一个迭代器"><a href="#创建一个迭代器" class="headerlink" title="创建一个迭代器"></a>创建一个迭代器</h3><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <code>iter()</code> 与 <code>next()</code> 。</p><ol><li><p><code>iter()</code>方法返回一个特殊的迭代器对象,这个迭代器对象实现了<code>next()</code>方法并通过<code>StopIteration</code>异常标识迭代的完成。</p></li><li><p><code>next()</code>方法会返回<strong>下一个迭代器对象</strong>。</p></li><li><p><strong>StopIteration</strong></p><p><code>StopIteration</code> 异常用于标识<strong>迭代的完成</strong>，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 <code>StopIteration</code> 异常来结束迭代。</p></li></ol><blockquote><p> 创建一个返回数字的迭代器，初始值为 1，逐步递增 1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumbers</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 初始化迭代器</span><br>    self.a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> self<br> <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 迭代器返回值</span><br>    <span class="hljs-keyword">if</span> self.a &lt;= <span class="hljs-number">20</span>:<br>      x = self.a<br>      self.a += <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> x<br>    <span class="hljs-keyword">else</span>:<br>      <span class="hljs-keyword">raise</span> StopIteration<br> <br>myclass = MyNumbers()<br>myiter = <span class="hljs-built_in">iter</span>(myclass)<br> <br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> myiter:<br>  <span class="hljs-built_in">print</span>(x)<br><br><span class="hljs-comment"># fun2:</span><br>myiter = <span class="hljs-built_in">iter</span>(myclass)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br></code></pre></td></tr></table></figure><h3 id="for-循环的工作原理"><a href="#for-循环的工作原理" class="headerlink" title="for 循环的工作原理"></a>for 循环的工作原理</h3><p>for循环可以称之为叫<strong>迭代器循环</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">d = <span class="hljs-punctuation">&#123;</span>&#x27;a&#x27;<span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span>&#x27;b&#x27;<span class="hljs-punctuation">:</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span>&#x27;c&#x27;<span class="hljs-punctuation">:</span><span class="hljs-number">3</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ol><li><code>d.iter()</code> 得到一个迭代器对象</li><li><code>迭代器对象.next()</code> 拿到一个返回值，然后将该返回值赋值给k</li><li>循环往复,直到抛出<code>StopIteration</code>异常<strong>for循环会捕捉异常然后结束循环.</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> d:<span class="hljs-comment"># d_it = d.__iter__()</span><br>    <span class="hljs-built_in">print</span>(k)<span class="hljs-comment"># 循环k = d_it.__next__()直到抛出异常结束循环</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.txt&#x27;</span>,mode=<span class="hljs-string">&#x27;rt&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f: <span class="hljs-comment"># f.__iter__()</span><br>        <span class="hljs-built_in">print</span>(line)<br><br><span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment"># 原理同for循环</span><br></code></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>在 Python 中，使用了 <code>yield</code> 的函数被称为<strong>生成器</strong>（generator）。</p><p>跟普通函数不同的是，生成器是<strong>一个返回迭代器的函数</strong>，只能用于<strong>迭代操作</strong>，更简单点理解<strong>生成器就是一个迭代器</strong>。</p><p>在<strong>调用生成器</strong>运行的过程中，每次遇到 <code>yield</code> 时函数会<strong>暂停并保存当前所有的运行信息</strong>，<strong>返回 <code>yield</code> 的值</strong>, 并在下一次执行 <code>next()</code> 方法时<strong>从当前位置继续运行</strong>。</p><p><strong>调用一个生成器函数，返回的是一个迭代器对象。</strong></p><h3 id="生成器的使用"><a href="#生成器的使用" class="headerlink" title="生成器的使用"></a>生成器的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第一次&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第二次&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第三次&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第四次&#x27;</span>)<br><br>g = func()<br><span class="hljs-built_in">print</span>(g)<br><span class="hljs-comment"># 生成器就是迭代器</span><br><span class="hljs-comment"># 生成器函数返回的是可迭代对象.</span><br>g.__iter__()<br><br><span class="hljs-comment"># g.__next__()会触发函数体代码的运行，然后遇到yield停下来，将yield后的值</span><br><span class="hljs-comment"># 当做本次调用的结果返回</span><br>g = func()<br><span class="hljs-comment"># 可以用iter将可迭代对象转化为迭代器.用next()方法</span><br><span class="hljs-built_in">print</span>(g)<br><br>g.__iter__()<br><br>res1 = g.__next__()<br><span class="hljs-comment"># 第一次</span><br><span class="hljs-built_in">print</span>(res1)<br><span class="hljs-comment"># 1</span><br><br>res2 = g.__next__()<br><span class="hljs-comment"># 第二次</span><br><span class="hljs-built_in">print</span>(res2)<br><span class="hljs-comment"># 2</span><br><br>res3 = g.__next__()<br><span class="hljs-comment"># 第三次</span><br><span class="hljs-built_in">print</span>(res3)<br><span class="hljs-comment"># 3</span><br><br>res4 = g.__next__()<br><span class="hljs-comment"># 第四次</span><br><span class="hljs-comment"># StopIteration</span><br></code></pre></td></tr></table></figure><p>实例:使用 <code>yield</code> 实现斐波那契数列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>):  <span class="hljs-comment"># 生成器函数 - 斐波那契</span><br>    a, b, counter = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> (counter &gt; n):<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">yield</span> a<br>        a, b = b, a + b<br>        counter += <span class="hljs-number">1</span><br><br><br>f = fibonacci(<span class="hljs-number">10</span>)  <span class="hljs-comment"># f 是一个迭代器，由生成器返回生成</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(f), end=<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h3 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a><code>yield</code>关键字</h3><p>yield关键字的作用是<strong>函数与调用者</strong>的通信，它不光能够将<strong>值返回给调用者</strong>，它还可以<strong>接收调用者传过来的值</strong>，那么怎么实现呢？ 调用者通过<code>send()</code>函数将值传递给<strong>generator</strong>，<strong>generator</strong>通过 <code>yield</code> 前面的变量(形如:<code>n = yield)</code>来接收</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>number = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>n = <span class="hljs-keyword">yield</span> number<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是yield关键字下面一行代码&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;调用者传递过来的值为:&#x27;</span>, n)<br> <br><br><span class="hljs-meta">&gt;&gt;&gt; </span>t = test()<br><span class="hljs-meta">&gt;&gt;&gt; </span>t.send(<span class="hljs-literal">None</span>)  <br><span class="hljs-comment"># 当第一次执行生成器的时候，需要传入None</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>t.send(<span class="hljs-number">1</span>)<br>我是<span class="hljs-keyword">yield</span>关键字下面一行代码<br>调用者传递过来的值为: <span class="hljs-number">1</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>t.send(<span class="hljs-number">2</span>)<br>我是<span class="hljs-keyword">yield</span>关键字下面一行代码<br>调用者传递过来的值为: <span class="hljs-number">2</span><br>t.close() 关闭generator后再调用，会出现StopIteration异常<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(t)<br>我是<span class="hljs-keyword">yield</span>关键字下面一行代码<br>调用者传递过来的值为: <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><blockquote><p>可以发现，<code>send</code>函数和<code>next</code>函数的区别就是 <code>send</code>函数可以在执行generator的<strong>过程中</strong>，给<strong>generator</strong>发送消息。<strong>而next仅仅是接收yield右边的变量值</strong>。</p></blockquote><h3 id="send-方法用法"><a href="#send-方法用法" class="headerlink" title="send()方法用法"></a><code>send()</code><strong>方法用法</strong></h3><ol start="0"><li><p><strong>send过来的数值 &#x3D; yield next出来的数值</strong></p></li><li><p>它的主要作用是，当我需要<strong>手动更改生成器里面的某一个值并且使用它</strong>，则<strong>send发送进去一个数据</strong>，然后<strong>保存到yield语句的返回值</strong>，以提供使用.</p></li><li><p><code>send()</code>的返回值就是那个<strong>本来应该被迭代出来的那个值</strong>。这样既可以<strong>保证我能够传入新的值，原来的值也不会弄丢.</strong></p></li><li><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_generator</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;定义一个生成器&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-comment"># send来的数值 = yield 数值</span><br>        num = <span class="hljs-keyword">yield</span> i<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;传入的<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)<br><br>g = my_generator(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br>a = g.send(<span class="hljs-number">100</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是&#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-string">&#x27;&#x27;&#x27; 结果</span><br><span class="hljs-string">0</span><br><span class="hljs-string">传入的None</span><br><span class="hljs-string">1</span><br><span class="hljs-string">传入的100 </span><br><span class="hljs-string">我是2     </span><br><span class="hljs-string">传入的None</span><br><span class="hljs-string">3</span><br><span class="hljs-string">传入的None</span><br><span class="hljs-string">4</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="throw-方法用法"><a href="#throw-方法用法" class="headerlink" title="throw()方法用法"></a><code>throw()</code>方法用法</h3><blockquote><p>简单来说就是:<strong>向生成器扔去一个异常,使生成器停止.</strong></p></blockquote><p><code>raise exception in generator，return next yielded value or StopIteration</code>，即在<strong>生成器中抛出异常</strong>，并且这个throw函数会<strong>返回下一个要迭代的值</strong>或者是<strong>StopIteration</strong>。还是通过几个例子来看吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_generator</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;a&#x27;</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;b&#x27;</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;c&#x27;</span><br>g = my_generator()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-------------------------&#x27;</span>)<br><span class="hljs-built_in">print</span>(g.throw(StopIteration))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">a</span><br><span class="hljs-string">b</span><br><span class="hljs-string">-------------------------</span><br><span class="hljs-string">StopIteration</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="生成器的启动与关闭close"><a href="#生成器的启动与关闭close" class="headerlink" title="生成器的启动与关闭close"></a><strong>生成器的启动与关闭close</strong></h3><ol><li><p><strong>生成器的启动</strong></p><p><strong>方法1：</strong>直接使用<code>next(g)</code>，这会<strong>直接开始迭代第一个元素</strong>（<strong>推荐使用这个启动</strong>）</p><p><strong>方法2：</strong>使用<code>g.send(None)</code>进行启动，注意<strong>第一次启动的时候只能传入<code>None</code><strong>，如果传入其他具体的指则会</strong>报错</strong>哦！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_generator</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span><br> <br>g = my_generator()<br>g.send(<span class="hljs-literal">None</span>)   <span class="hljs-comment">#第一次启动，本来第一次应该迭代的1，这里被取代了，但是send(None)会返回1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br> <br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">2</span><br><span class="hljs-string">3</span><br><span class="hljs-string">4</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>生成器的关闭</strong></p><p>如果一个生成器被<strong>中途关闭</strong>之后，在此调用<code>next()</code>方法，则会显示错误，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_generator</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span><br> <br>g = my_generator()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br>g.close()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))   <span class="hljs-comment">#在此处会显示错误</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">1</span><br><span class="hljs-string">2</span><br><span class="hljs-string">显示StopIteration</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="生成器的终止迭代——StopIteration"><a href="#生成器的终止迭代——StopIteration" class="headerlink" title="生成器的终止迭代——StopIteration"></a><strong>生成器的终止迭代——<code>StopIteration</code></strong></h3><blockquote><p>前面讲的手动关闭生成器，使用<code>close()</code>方法，后面的迭代会抛出<code>StopIteration</code>异常。</p></blockquote><p>在一个生成器中，如果没有<code>return</code>，则默认执行到函数完毕时返回<code>StopIteration</code>:</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">g1</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>g = g1()<br><span class="hljs-built_in">next</span>(g)    <span class="hljs-comment">#第一次调用next(g)时，会在执行完yield语句后挂起，所以此时程序并没有执行结束。</span><br><span class="hljs-built_in">next</span>(g)    <span class="hljs-comment">#程序试图从yield语句的下一条语句开始执行，发现已经到了结尾，所以抛出StopIteration异常。</span><br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">1</span><br><span class="hljs-string">Traceback (most recent call last):</span><br><span class="hljs-string">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="hljs-string">StopIteration</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p> 如果遇到<code>return</code>,如果在执行过程中return，则直接抛出 <code>StopIteration</code> 终止迭代:</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">g2</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;a&#x27;</span><br>    <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;b&#x27;</span><br>g=g2()<br><span class="hljs-built_in">next</span>(g)    <span class="hljs-comment">#程序停留在执行完yield &#x27;a&#x27;语句后的位置。</span><br><span class="hljs-built_in">next</span>(g)    <span class="hljs-comment">#程序发现下一条语句是return，所以抛出StopIteration异常，这样yield &#x27;b&#x27;语句永远也不会执行。</span><br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">a</span><br><span class="hljs-string">b</span><br><span class="hljs-string">Traceback (most recent call last):</span><br><span class="hljs-string">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="hljs-string">StopIteration</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>如果在<code>return</code>后返回一个值，那么这个值为<code>StopIteration</code>异常的说明，不是程序的返回值。</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">g3</span>():<br> <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;a&#x27;</span><br> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是错误说明&#x27;</span><br> <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;b&#x27;</span>   <span class="hljs-comment">#有一些编辑器会提示错误，此处为unreachable code，即不可到达的代码</span><br>g=g3()<br><span class="hljs-built_in">next</span>(g)<br><span class="hljs-built_in">next</span>(g)<br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">a</span><br><span class="hljs-string">Traceback (most recent call last):</span><br><span class="hljs-string"> File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="hljs-string">StopIteration: 这是错误说明</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>生成器没有办法使用<code>return</code>来返回值。因为<code>return</code>返回的那个值是通过<strong>StopIteration的异常信息</strong>返回的，所以没办法<strong>直接获取这个return返回的值</strong>。</p></blockquote><p>当然上面所说的无法获取<strong>return返回值</strong>，我们指的是没有办法通过<code>result=g3()</code>这种形式获取<strong>return的返回值</strong>。实际上还是有手段获取这个<strong>return的值的</strong>，有两种方法：</p><ol><li><p>使用<code>yield from</code>语句</p></li><li><p>因为<code>return</code>返回的值是作为<strong>StopIteration的一个value属性存在的</strong>，StopIteration本质上是<strong>一个类</strong>，所以可以通过访问它的<strong>value属性获取这个return返回的值</strong>。使用下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">g3</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;a&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是错误说明&#x27;</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;b&#x27;</span><br>g=g3()<br> <br><span class="hljs-keyword">try</span>:   <br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))  <span class="hljs-comment">#a</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))  <span class="hljs-comment">#触发异常</span><br><span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> exc:<br>    result=exc.value<br>    <span class="hljs-built_in">print</span>(result)<br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">a</span><br><span class="hljs-string">这是错误说明</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="yield实现协程"><a href="#yield实现协程" class="headerlink" title="yield实现协程"></a><strong><code>yield</code>实现协程</strong></h3><p>在Python中，协程通过<code>yield</code>实现。因为当<strong>一个函数中有yield存在</strong>的时候，这个函数是<strong>生成器</strong>，那么当你调用这个函数的时候，你在函数体中写的代码<strong>并没有被执行</strong>，而是<strong>只返回了一个生成器对象</strong>，这个需要特别注意。然后，你的代码将会在每次使用这个生成器的时候被执行。</p><p>前面讲过<strong>yield表达式</strong>的两个关键作用：<strong>①返回一个值、②接收调用者的参数</strong></p><p><strong>“调用者”与“被调用者”</strong>之间的通信是通过<code>send()</code>进行联系的</p><p>正是因为<code>yield</code>实现的生成器具备<strong>“中断等待的功能”</strong>，才使得yield可以实现<strong>协程</strong>。</p><ol><li><p>例子1:<strong>生产者-消费者模型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>():<br>    r = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        n = <span class="hljs-keyword">yield</span> r  <span class="hljs-comment">#执行的中断点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> n:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[消费者] 正在消费:&#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(n))<br>        r = <span class="hljs-string">&#x27;200 人民币&#x27;</span><br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">produce</span>(<span class="hljs-params">c</span>):<br>    c.send(<span class="hljs-literal">None</span>)  <span class="hljs-comment">#启动消费者（生成器）——实际上是函数调用，只不过生成器不是直接象函数那般调用的</span><br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">5</span>:<br>        n = n + <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[生产者] 正在生产:&#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(n))<br>        r = c.send(n) <span class="hljs-comment">#给消费者传入值——实际上也是函数调用</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[生产者] 消费者返回:&#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(r))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-------------------------------------------------&#x27;</span>)<br>    c.close()<br> <br>c = consumer()<span class="hljs-comment">#构造一个生成器</span><br>produce(c)<br> <br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">[生产者] 正在生产:1</span><br><span class="hljs-string">[消费者] 正在消费:1</span><br><span class="hljs-string">[生产者] 消费者返回:200 人民币</span><br><span class="hljs-string">-------------------------------------------------</span><br><span class="hljs-string">[生产者] 正在生产:2</span><br><span class="hljs-string">[消费者] 正在消费:2</span><br><span class="hljs-string">[生产者] 消费者返回:200 人民币</span><br><span class="hljs-string">-------------------------------------------------</span><br><span class="hljs-string">[生产者] 正在生产:3</span><br><span class="hljs-string">[消费者] 正在消费:3</span><br><span class="hljs-string">[生产者] 消费者返回:200 人民币</span><br><span class="hljs-string">-------------------------------------------------</span><br><span class="hljs-string">[生产者] 正在生产:4</span><br><span class="hljs-string">[消费者] 正在消费:4</span><br><span class="hljs-string">[生产者] 消费者返回:200 人民币</span><br><span class="hljs-string">-------------------------------------------------</span><br><span class="hljs-string">[生产者] 正在生产:5</span><br><span class="hljs-string">[消费者] 正在消费:5</span><br><span class="hljs-string">[生产者] 消费者返回:200 人民币</span><br><span class="hljs-string">-------------------------------------------------</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><p>协程其实就是一个<strong>可以暂停执行</strong>的函数，并且<strong>可以恢复继续执行</strong>。那么<code>yield</code>已经可以<strong>暂停执行</strong>了，如果在暂停后有办法把一些 <code>value</code> 发回到<strong>暂停执行的函数</strong>中，那么 Python 就有了<strong>『协程』</strong>。于是有了, <strong>“把东西发送到已经暂停的生成器中”</strong> 的方法，这个方法就是<code>send()</code>。</p><h3 id="yield-from-的简单实现"><a href="#yield-from-的简单实现" class="headerlink" title="yield from 的简单实现"></a><code>yield from</code> 的简单实现</h3><p>yield是每次<strong>“惰性返回”一个值</strong>，其实从名字中就能看出，<code>yield from</code> 是<code>yield</code>的升级改进版本，如果将<strong>yield理解成“返回”</strong>，那么yield from就是<strong>“从什么（生成器）里面返回”</strong>，这就构成了<code>yield from</code>的一般语法，即:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> 生成器()<br></code></pre></td></tr></table></figure><p><strong>其实她等同于:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> 生成器():<br>    <span class="hljs-keyword">yield</span> item<br></code></pre></td></tr></table></figure><p>这样的形式。我们通过一个简单例子来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator2</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;a&#x27;</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;b&#x27;</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;c&#x27;</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> generator1() <span class="hljs-comment">#yield from iterable本质上等于 for item in iterable: yield item的缩写版</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> [<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>]<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> (<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">34</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> generator2():<br>    <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">&#x27; , &#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;运行的结果为：</span><br><span class="hljs-string">a , b , c , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 11 , 22 , 33 , 44 , 12 , 23 , 34 , 0 , 1 , 2 ,</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><code>yield from</code> 后面可以跟的可以是  <strong>“ 生成器 、元组、 列表、range()函数产生的序列等可迭代对象”</strong></p><p>简单地说,<code>yield from  generator</code> 。实际上就是返回<strong>另外一个生成器</strong>。而<code>yield</code>只是返回<strong>一个元素</strong>。从这个层面来说，有下面的等价关系：<strong>yield from iterable本质上等于 for item in iterable: yield item 。</strong></p><h3 id="yield-from的高级应用"><a href="#yield-from的高级应用" class="headerlink" title="yield from的高级应用"></a><code>yield from</code>的高级应用</h3><h4 id="1-针对yield无法获取生成器return的返回值"><a href="#1-针对yield无法获取生成器return的返回值" class="headerlink" title="1. 针对yield无法获取生成器return的返回值"></a><strong>1. 针对yield无法获取生成器return的返回值</strong></h4><blockquote><p>在使用<strong>yield生成器</strong>的时候，如果使用<strong>for语句去迭代生成器</strong>，则不会显式的发出<strong>StopIteration异常</strong>，而是<strong>自动捕获StopIteration异常</strong>，所以如果<strong>遇到return，只是会终止迭代，而不会触发异常</strong>，故而也就<strong>没办法获取return的值</strong>。如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_generator</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">if</span> i==<span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我被迫中断了&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">yield</span> i<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">generator</span>):<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> generator:  <span class="hljs-comment">#不会显式触发异常，故而无法获取到return的值</span><br>            <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> exc:<br>        <span class="hljs-built_in">print</span>(exc.value)<br> <br>g = my_generator()  <span class="hljs-comment">#调用</span><br>main(g)<br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">0</span><br><span class="hljs-string">1</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>for迭代语句不会显式触发异常</strong>，故而无法获取到<strong>return的值</strong>，迭代到2的时候<strong>遇到return语句</strong>，<strong>隐式的触发了StopIteration异常</strong>，就<strong>终止迭代</strong>了，但是在程序中<strong>不会显示出来</strong>。</p><p>如果是使用<code>next()</code><strong>一次一次迭代</strong>，则会<strong>显式触发异常</strong>，但要获取return的返回值，我需要如下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_generator</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">if</span> i==<span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我被迫中断了&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">yield</span> i<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">generator</span>):<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))   <span class="hljs-comment">#每次迭代一个值，则会显式出发StopIteration</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))<br>    <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> exc:<br>        <span class="hljs-built_in">print</span>(exc.value)     <span class="hljs-comment">#获取返回的值</span><br><br>g=my_generator()<br>main(g)<br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">0</span><br><span class="hljs-string">1</span><br><span class="hljs-string">我被迫中断了</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>现在我们使用<code>yield from</code>来完成上面的同样的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">生成器中<span class="hljs-keyword">return</span>的值 = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> 生成器对象<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_generator</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span>:<br>            <span class="hljs-comment"># 遇到return自动触发StopIteration异常</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我被迫中断了&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">yield</span> i<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wrap_my_generator</span>(<span class="hljs-params">generator</span>):  <span class="hljs-comment"># 定义一个包装“生成器”的生成器，它的本质还是生成器</span><br>    result = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> generator    <span class="hljs-comment"># 自动触发StopIteration异常，并且将return的返回值赋值给yield from表达式的结果，即result</span><br>    <span class="hljs-built_in">print</span>(result)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">generator</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> generator:<br>        <span class="hljs-built_in">print</span>(j)<br> <br>g = my_generator()<br>wrap_g = wrap_my_generator(g)<br>main(wrap_g)  <span class="hljs-comment">#调用</span><br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">0</span><br><span class="hljs-string">1</span><br><span class="hljs-string">我被迫中断了</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>从上面的比较可以看出，<code>yield from</code>具有以下几个<strong>特点</strong>：</p><ol><li><p><strong>单独<code>yield</code>时</strong>：的my_generator是原始的生成器，main是调用方，使用yield的时候，只涉及到这两个函数，即“调用方”与“生成器（协程函数）”是<strong>直接进行交互的，不涉及其他方法</strong>，即<strong>“调用方——&gt;生成器函数(协程函数)”；</strong></p></li><li><p><strong>在使用<code>yield from</code>的时</strong>：多了一个对原始my_generator的<strong>包装函数</strong>，然后<strong>调用方是通过这个包装函数</strong>（后面会讲到它专有的名词）来与<strong>生成器进行交互</strong>的，即<strong>“调用方——&gt;生成器包装函数——&gt;生成器函数(协程函数)”</strong>；</p></li><li><p><code>yield from iteration</code>结构会在内部<strong>自动捕获 iteration生成器的StopIteration 异常</strong>。这种处理方式与 for 循环处理 StopIteration 异常的方式一样。而且对 <code>yield from</code>结构来说，<strong>解释器不仅会捕获 StopIteration 异常，还会把return返回的值或者是StopIteration的value 属性的值变成 yield from 表达式的值，即上面的result。</strong></p></li></ol><blockquote><p>委派生成器：包含 <code>yield from</code> <iterable> <strong>表达式的生成器函数</strong>；即上面的wrap_my_generator<strong>生成器包装函数</strong></p></blockquote><blockquote><p>子生成器：从 <code>yield from</code> 表达式中 <iterable> 部分获取的生成器；即上面的my_generator<strong>生成器函数</strong></p></blockquote><blockquote><p>调用方：<strong>调用委派生成器的客户端代码</strong>；即上面的<strong>main调用方函数</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210814184753.png"></p><h4 id="2-yield-from的管道传输用法示例"><a href="#2-yield-from的管道传输用法示例" class="headerlink" title="2. yield from的管道传输用法示例"></a>2. yield from的管道传输用法示例</h4><p>其实<code>yield from</code>最重要的作用就是提供了一个<strong>“数据传输的管道”</strong>，下面通过一个简单的例子加以说明为什么是管道：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">average</span>():<br>    total = <span class="hljs-number">0.0</span>  <span class="hljs-comment">#数字的总和</span><br>    count = <span class="hljs-number">0</span>    <span class="hljs-comment">#数字的个数</span><br>    avg = <span class="hljs-literal">None</span>   <span class="hljs-comment">#平均值</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        num = <span class="hljs-keyword">yield</span> avg<br>        total += num<br>        count += <span class="hljs-number">1</span><br>        avg = total/count<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wrap_average</span>(<span class="hljs-params">generator</span>):<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> generator<br> <br><span class="hljs-comment">#定义一个函数，通过这个函数向average函数发送数值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">wrap</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(wrap))  <span class="hljs-comment">#启动生成器</span><br>    <span class="hljs-built_in">print</span>(wrap.send(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 10</span><br>    <span class="hljs-built_in">print</span>(wrap.send(<span class="hljs-number">20</span>))  <span class="hljs-comment"># 15</span><br>    <span class="hljs-built_in">print</span>(wrap.send(<span class="hljs-number">30</span>))  <span class="hljs-comment"># 20</span><br>    <span class="hljs-built_in">print</span>(wrap.send(<span class="hljs-number">40</span>))  <span class="hljs-comment"># 25</span><br>  <br>g = average()<br>wrap = wrap_average(g)<br>main(wrap)<br> <br><span class="hljs-string">&#x27;&#x27;&#x27;运行结果为：</span><br><span class="hljs-string">None</span><br><span class="hljs-string">10.0</span><br><span class="hljs-string">15.0</span><br><span class="hljs-string">20.0</span><br><span class="hljs-string">25.0</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>从上面我们可以发现，调用方发送的数据是发给<code>wrap_average</code>的，怎么依然到了生成器函数<code>average</code>里面呢？这就是<strong>“数据传输管道的作用”</strong>。即<strong>主函数调用方main把各个value传给grouper</strong> ，而这个传入的值<strong>最终到达averager函数中</strong>； <strong>grouper并不知道传入的是什么值</strong>，因为从上面的代码看出，**<code>wrap_average</code>里面完全没有处理这个值的任何代码！**</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-built_in">print</span>(test)<br><span class="hljs-comment"># &lt;function __main__.test&gt;</span><br>a = test <span class="hljs-comment"># 变量A指向函数对象</span><br>a() <span class="hljs-comment"># 变量A可调用函数</span><br></code></pre></td></tr></table></figure><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><blockquote><p><strong>在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这些函数以及用到的一些变量称之为闭包。</strong></p></blockquote><h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">number: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第一层函数&quot;</span>, number)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">number2</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第二层函数加和后&quot;</span>, number+number2)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br><span class="hljs-comment"># 接受函数对象的引用</span><br>func = parse(<span class="hljs-number">100</span>)<br>func(<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>   <img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210719211704.png"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210719215011.png"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210719215459.png"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210719215842.png"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210719220126.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 编写闭包函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">checkLogin</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备检查权限&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;权限正确!&quot;</span>)<br>        func()  <span class="hljs-comment"># 执行函数的变量</span><br><br>    <span class="hljs-keyword">return</span> inner  <span class="hljs-comment"># 返回一个函数对象</span><br><br><span class="hljs-comment"># main变量指向的是mian函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行业务1&quot;</span>)<br><br><span class="hljs-comment"># 不用修改主函数的内容,就可以扩展主函数.</span><br>main = checkLogin(main)  <span class="hljs-comment"># 此时main变量指向的是inner函数</span><br>main()<br><span class="hljs-comment"># 等效于</span><br><span class="hljs-comment"># 到这里python会运行 checkLogin函数,并把下面的函数名变量指向 checkLogin 函数的返回值,即 inner 函数</span><br><span class="hljs-meta">@checkLogin</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mian</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行业务2&quot;</span>)<br><br><span class="hljs-comment"># 在调用main之前已经被装饰了</span><br>mian()<br></code></pre></td></tr></table></figure><h3 id="多个修饰器，从下到上修饰"><a href="#多个修饰器，从下到上修饰" class="headerlink" title="多个修饰器，从下到上修饰"></a>多个修饰器，从下到上修饰</h3><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210720161511.png"></p><blockquote><p><strong>装饰是倒着装的，执行是顺着执行的。</strong></p></blockquote><h3 id="装饰有参数的函数"><a href="#装饰有参数的函数" class="headerlink" title="装饰有参数的函数"></a>装饰有参数的函数</h3><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210720162540.png"></p><blockquote><p>对不定长参数的传递</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210720162754.png"></p><h3 id="装饰有返回值的参数"><a href="#装饰有返回值的参数" class="headerlink" title="装饰有返回值的参数"></a>装饰有返回值的参数</h3><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210720163328.png" alt="image-20210720163327239"></p><h3 id="通用修饰器"><a href="#通用修饰器" class="headerlink" title="通用修饰器"></a>通用修饰器</h3><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210720164146.png"></p><h3 id="带参数的修饰器"><a href="#带参数的修饰器" class="headerlink" title="带参数的修饰器"></a>带参数的修饰器</h3><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210818144548.png"></p><blockquote><p>在函数中嵌套闭包函数</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😭2021年广东数学中考体验</title>
    <link href="/2021/06/28/zhongkao-maths/"/>
    <url>/2021/06/28/zhongkao-maths/</url>
    
    <content type="html"><![CDATA[<h1 id="😭😭😭2021年广东数学中考体验"><a href="#😭😭😭2021年广东数学中考体验" class="headerlink" title="😭😭😭2021年广东数学中考体验"></a>😭😭😭2021年广东数学中考体验</h1><h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><blockquote><p><strong>不请自来，这张试卷太气人了。这几个月刷了那么多道题，做了那么多练习，根本没什么卵用，考的都是什么奇奇怪怪的东西，选择题不知道第几题开始，人都傻了，那个秦九韶老师都没讲过，也没做过相关练习，还有就是证明圆相切，最后压轴题就真的气人！！！本来想着冲一波高分，现在别说高分，及格都不一定，一大堆没写完。</strong></p></blockquote><blockquote><p><strong>试题可以接地气，不可以接地府</strong>.</p></blockquote><blockquote><p><strong>“出题人是神经病”</strong></p></blockquote><blockquote><p><strong>数学最后一题，深圳18年高三一模原题</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629023311.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629023333.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629023357.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629023434.jpeg" alt="img"></p><hr><p><strong>好吧。当我见到答题卡的时候，简单的图形，没有圆，尺规作图在第二十题（因为那里是个孤零零的直角三角形），二十四题貌似是个手拉手，二十五题没有图。</strong></p><p>等到试卷发下来，通览全卷，问题感觉不大。考试开始…..</p><p><strong>发下答题卡，25没图？？？24没圆？？？</strong></p><p>我察觉到了<strong>危险</strong>。</p><p>发下试卷，翻到最后，25最后一小问平行<strong>四边形存在性问题</strong>，还好是<strong>送分</strong>。</p><p>问题是第一问是什么？！二次不等式？！</p><p>我深吸一口气，决定这次做快点。</p><p>翻回去，考前五分钟做会选择。</p><p>第三题概率是我做<strong>概率选择题最久的一题</strong>（因为一般都是在几个中选几个，这次绕了点），这足以说明试卷的水平不简单。</p><p>第九题<strong>海伦公式</strong>,听说过,不会写,跳!</p><p>第十题类型题我刷过，那个AB会过定点，<strong>辅助线是三垂直</strong>，但是没有记的情况是定点(0,1)，当时为了赶时间（<strong>别问为什么这么赶</strong>，只有90分钟啊，90分钟！！！）我跳了这题。</p><p><strong>第十五题</strong>为什么不是  $ x^{2}+\frac{1}{x^{2}} $ 而是 $ x^{2}-\frac{1}{x^{2}} $<br>完了，<strong>硬算很费时间</strong>，跳了。</p><p>第十六题<strong>暴力三角函数相似勾股</strong>，有点费。但是算对了.</p><p>第十七题，<strong>定弦对等角出隐圆</strong>，作等腰直角三角形顶点就是圆心，<del>挺简单的</del>。</p><p>到大题了，第十八题居然<strong>不是算术</strong>，感觉不对劲。</p><p>第二十一题做着感觉没问题，出答案的时候k值有两个？！完了我<strong>漏解没了</strong>。。。</p><p>当我做<strong>二十三折叠题</strong>的时候，抬了下头，不到30分钟了？？？！！！</p><p>不行了，后面还有道证明题，这折叠题算了,写了几个<strong>可能的步骤</strong>.跳!</p><blockquote><p>时间还剩20分钟……</p></blockquote><p>证明题二十四题<strong>第一问还行，送分</strong>。</p><p>第二问我圆呢？自己作？算了这题跳了，<strong>写下取AD中点M，设半径，不知道有没有分</strong>。</p><p>第三问我标了下长度，发现了三角形的<strong>面积</strong>可以通过<strong>等积变形</strong>转换,又有两个<strong>三角函数</strong>,求出<strong>底和高</strong>,搞定!。</p><blockquote><p>时间还剩<strong>10分钟</strong>左右…</p></blockquote><p>最后一道压轴题，<strong>第一问我满脸问号？？？这什么玩意儿？？</strong></p><p>我求下导，画下草图，这形式有点像<strong>夹逼定理</strong>！（只是<strong>看着像而已</strong>）</p><p>一番惊奇过后，我认真思考下，要求不等式<strong>两边函数的切点</strong>，我求了，然后满脑空白，<strong>不知道接下来要做什么。。。</strong></p><p>抬头看了时间，<strong>我苦笑了下，五分钟不到了。</strong></p><p>于是我就开始<strong>蒙a的值</strong>，太大怕和上面的抛物线相交，太小又怕和下面那条直线相交。</p><p>我痛定思痛，<strong>就蒙a&#x3D;2（然而答案是1）</strong>，把抛物线求了出来，仅此而已。</p><p><strong>我跳回去，选择第十题蒙C</strong>（答案是A，而且图里也没有30°之类的东西，不可能出现这种数，大意了，但都快要收卷了谁还会管呀），填空<strong>第十五题蒙了</strong>。</p><blockquote><p><strong>打铃，收卷。</strong></p></blockquote><h2 id="网上看到的一个关于广东中考的段子"><a href="#网上看到的一个关于广东中考的段子" class="headerlink" title="网上看到的一个关于广东中考的段子"></a>网上看到的一个关于<code>广东中考</code>的段子</h2><blockquote><p>我站在<strong>望北哨所</strong>，手里拿着<strong>红绸带</strong>，脑中思索着<strong>隐圆计算</strong>，收到了2kg荔枝，但是我只想吃<strong>豆沙粽</strong>和<strong>猪肉粽</strong>。恍惚间，我看到一辆跑车超速驶来，我连忙用<strong>超声波计算</strong>，制止了他的行为。我郑重的说:“ 先生，你这样不利于实现<strong>碳达峰和碳中和</strong>。他的眼中饱含泪水，注视着我，大喊一声:“这才是<strong>少年应有的模样</strong>!”</p></blockquote><h2 id="2021-年-广东中考数学-今年-题目-解析"><a href="#2021-年-广东中考数学-今年-题目-解析" class="headerlink" title="2021 年 广东中考数学  (今年) 题目+解析"></a><strong>2021</strong> 年 <strong>广东中考数学</strong>  (<strong>今年</strong>) 题目+解析</h2><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629015828.png"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629015859.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629015950.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629020000.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629020011.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629020026.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629020045.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629020057.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629020109.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629020123.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629020134.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629020207.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629020229.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629020320.png" alt="img"></p><blockquote><p>附: <strong>2020</strong>年 <strong>广东中考数学</strong> (去年的,对比一下)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629014918.jpg" alt="第1页(共4页)"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629014936.jpg" alt="第2页(共4页)"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629015036.jpg" alt="第3页(共4页)"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210629015051.jpeg" alt="第4页(共4页)"></p>]]></content>
    
    
    <categories>
      
      <category>schoolWork</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maths</tag>
      
      <tag>Test</tag>
      
      <tag>schoolWork</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KaliLinuxHelp</title>
    <link href="/2021/06/18/Kali-Linux-Help/"/>
    <url>/2021/06/18/Kali-Linux-Help/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619154844.jpg" alt="Kali"></p><h1 id="Kali-Linux-漏洞审计-批量扫描-弱密码撞库-教程"><a href="#Kali-Linux-漏洞审计-批量扫描-弱密码撞库-教程" class="headerlink" title="Kali Linux 漏洞审计 批量扫描 弱密码撞库 教程"></a>Kali Linux 漏洞审计 批量扫描 弱密码撞库 教程</h1><h1 id="nmap端口扫描"><a href="#nmap端口扫描" class="headerlink" title="nmap端口扫描"></a>nmap端口扫描</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>sudo apt-get install nmap</code></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>nmap [扫描类型] [扫描参数] [hosts 地址与范围]</code></p><h2 id="扫描类型"><a href="#扫描类型" class="headerlink" title="扫描类型"></a>扫描类型</h2><ul><li><p>-sT    TCP connect() 扫描，这是最基本的 TCP 扫描方式。这种扫描很容易被检测到，在目标主机的日志中会记录大批的连接请求以及错误信息。     </p></li><li><p>-sS    TCP 同步扫描 (TCP SYN)，因为不必全部打开一个 TCP 连接，所以这项技术通常称为半开扫描 (half-open)。这项技术最大的好处是，很少有系统能够把这记入系统日志。不过，你需要 root 权限来定制 SYN 数据包。     </p></li><li><p>-sF,-sX,-sN    秘密 FIN 数据包扫描、圣诞树 (Xmas Tree)、空 (Null) 扫描模式。这些扫描方式的理论依据是：关闭的端口需要对你的探测包回应 RST 包，而打开的端口必需忽略有问题的包（参考 RFC 793 第 64 页）。     </p></li><li><p>-sP    ping 扫描，用 ping 方式检查网络上哪些主机正在运行。当主机阻塞 ICMP echo 请求包是 ping 扫描是无效的。nmap 在任何情况下都会进行 ping 扫描，只有目标主机处于运行状态，才会进行后续的扫描。     </p></li><li><p>-sU    UDP 的数据包进行扫描，如果你想知道在某台主机上提供哪些 UDP（用户数据报协议，RFC768) 服务，可以使用此选项。     </p></li><li><p>-sA    ACK 扫描，这项高级的扫描方法通常可以用来穿过防火墙。     -sW    滑动窗口扫描，非常类似于 ACK 的扫描。     </p></li><li><p>-sR    RPC 扫描，和其它不同的端口扫描方法结合使用。     -b    FTP 反弹攻击 (bounce attack)，连接到防火墙后面的一台 FTP 服务器做代理，接着进行端口扫描。</p></li></ul><h2 id="扫描参数"><a href="#扫描参数" class="headerlink" title="扫描参数"></a>扫描参数</h2><ul><li>-P0    在扫描之前，不 ping 主机。    </li><li>-PT    扫描之前，使用 TCP ping 确定哪些主机正在运行。     </li><li>-PS    对于 root 用户，这个选项让 nmap 使用 SYN 包而不是 ACK 包来对目标主机进行扫描。    </li><li>-PI    设置这个选项，让 nmap 使用真正的 ping(ICMP echo 请求）来扫描目标主机是否正在运行。    </li><li>-PB    这是默认的 ping 扫描选项。它使用 ACK(-PT) 和 ICMP(-PI) 两种扫描类型并行扫描。如果防火墙能够过滤其中一种包，使用这种方法，你就能够穿过防火墙。     </li><li>-O    这个选项激活对 TCP&#x2F;IP 指纹特征 (fingerprinting) 的扫描，获得远程主机的标志，也就是操作系统类型。     </li><li>-I    打开 nmap 的反向标志扫描功能。    </li><li>-f    使用碎片 IP 数据包发送 SYN、FIN、XMAS、NULL。包增加包过滤、入侵检测系统的难度，使其无法知道你的企图。     </li><li>-v    冗余模式。强烈推荐使用这个选项，它会给出扫描过程中的详细信息。     </li><li>-S  <IP>   在一些情况下，nmap 可能无法确定你的源地址 (nmap 会告诉你）。在这种情况使用这个选项给出你的 IP 地址。    </li><li>-g port    设置扫描的源端口。一些天真的防火墙和包过滤器的规则集允许源端口为 DNS(53) 或者 FTP-DATA(20) 的包通过和实现连接。显然，如果攻击者把源端口修改为 20 或者 53，就可以摧毁防火墙的防护。     </li><li>-oN    把扫描结果重定向到一个可读的文件 logfilename 中。    </li><li>-oS    扫描结果输出到标准输出。    </li><li>–host_timeout    设置扫描一台主机的时间，以毫秒为单位。默认的情况下，没有超时限制。     </li><li>–max_rtt_timeout    设置对每次探测的等待时间，以毫秒为单位。如果超过这个时间限制就重传或者超时。默认值是大约 9000 毫秒。    </li><li>–min_rtt_timeout    设置 nmap 对每次探测至少等待你指定的时间，以毫秒为单位。    </li><li>-M count    置进行 TCP connect() 扫描时，最多使用多少个套接字进行并行的扫描。</li></ul><h2 id="端口状态"><a href="#端口状态" class="headerlink" title="端口状态"></a>端口状态</h2><ul><li>Open（开放的）意味着目标机器上的应用程序正在该端口监听连接 &#x2F; 报文。</li><li>filtered（被过滤的） 意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，Nmap 无法得知 它是 open（开放的） 还是 closed（关闭的）。  </li><li>closed（关闭的） 端口没有应用程序在它上面监听，但是他们随时可能开放。 </li><li>unfiltered（未被过滤的）当端口对 Nmap 的探测做出响应，但是 Nmap 无法确定它们是关闭还是开放时 open filtered 开放或者被过滤的 closed filtered 关闭或者被过滤的</li></ul><h2 id="扫描实例"><a href="#扫描实例" class="headerlink" title="扫描实例"></a>扫描实例</h2><blockquote><p>阿里云服务器网段大全：<a href="https://blog.csdn.net/nxuu01/article/details/102779652">CSDN博客</a> <a href="https://blog.csdn.net/eagle_min/article/details/82260622">CSDN-eagle_min大佬</a></p><p>腾讯云ip段：<a href="https://blog.csdn.net/eagle_min/article/details/82260611">CSDN-eagle_min大佬</a></p></blockquote><ol><li>用nmap扫描该网段开放的888端口保存在pma.txt文件 格式要求：ip:port<br><code>nmap -vv -n --open -p 888 网段 | awk -F&#39;[ /]&#39; &#39;/Discovered open port/&#123;print $NF&quot;:&quot;$4&#125;&#39; &gt;&gt; pma.txt</code></li></ol><h1 id="Hydra-弱密码破解"><a href="#Hydra-弱密码破解" class="headerlink" title="Hydra 弱密码破解"></a>Hydra 弱密码破解</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p><code>sudo apt-get install hydra</code></p><blockquote><p>Hydra是一款<strong>非常强大的暴力破解工具</strong>，它是由著名的黑客组织THC开发的一款<strong>开源暴力破解工具</strong>。Hydra是一个验证性质的工具，主要目的是：展示安全研究人员从<strong>远程获取一个系统认证权限</strong>。</p></blockquote><h2 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h2><ul><li>-R: 继续从上一次进度接着破解</li><li>-S: 大写，采用SSL链接</li><li>-s <PORT>： 小写，可通过这个参数指定非默认端口</li><li>-l <LOGIN>： 指定破解的用户，对特定用户破解</li><li>-L <FILE>： 指定用户名字典</li><li>p <PASS>： 小写，指定密码破解，少用，一般是采用密码字典</li><li>-P <FILE>： 大写，指定密码字典</li><li>-e <ns>： 可选选项，n：空密码试探，s：使用指定用户和密码试探</li><li>-C <FILE>： 使用冒号分割格式，例如“登录名:密码”来代替 -L&#x2F;-P 参数</li><li>-M <FILE>： 指定目标列表文件一行一条</li><li>o <FILE>： 指定结果输出文件</li><li>-f ： 在使用-M参数以后，找到第一对登录名或者密码的时候中止破解</li><li>-t <TASKS>： 同时运行的线程数，默认为16</li><li>-w <TIME>： 设置最大超时的时间，单位秒，默认是30s</li><li>-v &#x2F; -V： 显示详细过程</li><li>server： 目标ip</li><li>service： 指定服务名，支持的服务和协议</li><li>OPT： 可选项</li></ul><hr><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="1-破解ssh"><a href="#1-破解ssh" class="headerlink" title="1.破解ssh"></a>1.破解ssh</h3><p><code>hydra -M sship.txt ssh -L user.txt -P passwd.txt -e ns -f -vV -t 4 -o ssh.txt</code></p><blockquote><p>-M 指定目标列表文件 一条一行</p><p>-L 指定用户字典 </p><p>-P 指定密码字典 </p><p>-e ns 空密码试探</p><p>-f 当破解一个成功密码就停止</p><p>-o 把成功的输出到ssh.txt文件 </p><p>-vV 显示详细信息</p></blockquote><h3 id="2-破解3389远程登录"><a href="#2-破解3389远程登录" class="headerlink" title="2.破解3389远程登录"></a>2.破解3389远程登录</h3><p><code>hydra -M rdpip.txt rdp -L user.txt -P passwd.txt -e ns -f -vV -t 16 -o rdp.txt</code></p><h3 id="3-破解MySQL数据库"><a href="#3-破解MySQL数据库" class="headerlink" title="3.破解MySQL数据库"></a>3.破解MySQL数据库</h3><p><code>hydra -M mysqlip.txt rdp -L user.txt -P passwd.txt -e ns -f -vV -t 16 -o mysql.txt</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 并发编程笔记</title>
    <link href="/2021/06/18/Python-Concurrent/"/>
    <url>/2021/06/18/Python-Concurrent/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-并发编程"><a href="#Python-并发编程" class="headerlink" title="Python 并发编程"></a>Python 并发编程</h1><h2 id="各并发技术"><a href="#各并发技术" class="headerlink" title="各并发技术"></a>各并发技术</h2><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210630200927.png"></p><h2 id="1-多线程-Thread（threading）"><a href="#1-多线程-Thread（threading）" class="headerlink" title="1. 多线程 Thread（threading）"></a>1. 多线程 Thread（threading）</h2><blockquote><ul><li><p>优点：<strong>相比进程，更轻量级、占用资源少.</strong></p></li><li><p>缺点：</p><ul><li>相比进程：多线程只能<strong>并发执行</strong>，<strong>不能利用多CPU（GIL）</strong></li><li>相比协程：启动数目<strong>有限制</strong>，占用内存资源，<strong>有线程切换开销</strong></li></ul></li><li><p>适用于：<strong>IO密集型计算</strong>、同时运行的任务数目要求不多</p></li></ul></blockquote><h3 id="多进程普通写法"><a href="#多进程普通写法" class="headerlink" title="多进程普通写法"></a>多进程普通写法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br>threads = [] <span class="hljs-comment"># 线程列表</span><br><br><span class="hljs-comment"># 为每个url创建一个线程对象并加入线程列表里</span><br><span class="hljs-comment"># target: 函数名 args: 函数参数(元组格式)</span><br><span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br>    threads.append(<br>        threading.Thread(target=craw, args=(url,))<br>    )<br><br><span class="hljs-comment"># 遍历线程列表启动线程</span><br><span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:<br>    thread.start()<br><br><span class="hljs-comment"># 等待线程结束再执行主线程</span><br><span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:<br>    thread.join()<br></code></pre></td></tr></table></figure><h3 id="利用线程池技术"><a href="#利用线程池技术" class="headerlink" title="利用线程池技术"></a>利用线程池技术</h3><blockquote><p>好处:新建线程系统需要<strong>分配资源</strong>、终止线程系统需要回收资源,线程池可以<strong>重用线程</strong>，则可以<strong>减去新建&#x2F;终止的开销</strong></p></blockquote><ul><li><p>原理</p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210630204323.png"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210630204353.png"></p></li><li><p>代码实现</p><ol><li><strong>map方式提交</strong></li></ol><blockquote><p><code>map</code> 的结果和入参是顺序对应的,且map传入函数参数时要传入<strong>参数列表</strong></p></blockquote><blockquote><p><a href="https://www.runoob.com/python3/python3-func-zip.html">Python Zip()函数</a></p><blockquote><p><strong>zip()</strong> 函数用于将<strong>可迭代的对象作为参数</strong>，将对象中<strong>对应的元素打包成一个个元组</strong>，然后返回由这些<strong>元组组成的对象</strong>，这样做的好处是<strong>节约了不少的内存</strong>。</p><p>我们可以使用 <code>list()</code> 转换来输出列表。</p><p><strong>元素个数与最短的列表一致</strong>.</p><p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 ***** 号操作符，可以将元组解压为列表。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210630211154.png" alt="&quot;形象&quot;"></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-comment"># 可以设置线程数</span><br><span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>) <span class="hljs-keyword">as</span> pool:<br>    <span class="hljs-comment"># map 向线程池提交任务,传入方法名,以及参数列表</span><br>    htmls = pool.<span class="hljs-built_in">map</span>(craw, urls)<br>    <span class="hljs-comment"># htmls urls(列表) 都是可迭代对象,可以用 zip 函数将他们打包成一个元组</span><br>    htmls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(urls, htmls))<br>    <span class="hljs-comment"># 结果和入参是顺序对应的</span><br>    <span class="hljs-keyword">for</span> url, html <span class="hljs-keyword">in</span> htmls:<br>        <span class="hljs-built_in">print</span>(url, <span class="hljs-built_in">len</span>(html))<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>submit 方式提交</strong></li></ol><blockquote><p><strong>future模式，更强大</strong>,注意如果用<code>as_completed</code>顺序是不定的</p></blockquote><blockquote><p><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">Python3 字典 items方法</a></p><blockquote><p>Python 字典 items() 方法以列表<strong>返回视图对象</strong>，是一个<strong>可遍历的 key&#x2F;value 对</strong>。</p></blockquote><p>将: <code>&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7&#125;</code> 变为: <code>[(&#39;Age&#39;, 7), (&#39;Name&#39;, &#39;Runoob&#39;)]</code></p></blockquote><ul><li><p><strong>方法一</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor,as_completed<br><span class="hljs-keyword">with</span> ThreadPoolExecutor() <span class="hljs-keyword">as</span> pool:<br>    <span class="hljs-comment"># 利用线程列表启动</span><br>    futures=[<br>        pool.submit(craw,url)<br>        <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls<br>    ]<br><br>    <span class="hljs-comment"># 通过遍历线程列表取出结果(要等所有结果运行完才有)</span><br>    <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> futures:<br>        <span class="hljs-built_in">print</span>(future.result())<br>        <br>    <span class="hljs-comment"># as_completed 不需要等待所有结果运行完才输出结果</span><br>    <span class="hljs-comment"># 一旦有结果运行完就会输出</span><br>    <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(futures):<br>        <span class="hljs-built_in">print</span>(future.result())<br></code></pre></td></tr></table></figure></li><li><p><strong>方法二</strong></p><blockquote><p><strong>适合需要与某一个量一一对应建立联系</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">with</span> ThreadPoolExecutor() <span class="hljs-keyword">as</span> pool:<br>    futures = &#123;&#125;  <span class="hljs-comment"># 字典,便于一一对应</span><br>    <span class="hljs-comment"># htmls格式: ([],[],[],..)</span><br>    <span class="hljs-comment"># 遍历元组的每个列表,把列表中的两个参数赋值给 url,html</span><br>    <span class="hljs-keyword">for</span> url, html <span class="hljs-keyword">in</span> htmls:<br>        <span class="hljs-comment"># submwit 提交,传入方法名和单个参数</span><br>        future = pool.submit(parse, html)<br>        <span class="hljs-comment"># 使用字典 将 future 对象与链接一一对应</span><br>        futures[future] = url<br>    <br>    <span class="hljs-comment"># 将转化为元组的字典遍历出来</span><br>    <span class="hljs-comment"># future-&gt;线程对象 url-&gt;线程对应的url</span><br>    <span class="hljs-keyword">for</span> future,url <span class="hljs-keyword">in</span> futures.items():<br>        <span class="hljs-comment"># 线程对象通过 result 取出运行结果</span><br>        <span class="hljs-built_in">print</span>(url,future.result())<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="生产者消费者模型-Producer-Consumer"><a href="#生产者消费者模型-Producer-Consumer" class="headerlink" title="生产者消费者模型  ( Producer, Consumer)"></a>生产者消费者模型  ( Producer, Consumer)</h3><ol><li><p>多组件的<code>Pipeline</code>技术架构</p><blockquote><p>复杂的事情一般都不会一下子做完，而是会分<strong>很多中间步骤一步步完成</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210703065209.png"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210703065255.png"></p></li><li><p><strong>多线程数据通信的<code>queue.Queue</code></strong></p><blockquote><p><code>queue.Queue</code>可以用于<strong>多线程之间</strong>的、<strong>线程安全</strong>的数据通信</p><p><strong>多个线程</strong> 可以 <strong>同时</strong> 读取 <strong>同一个队列</strong> </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1、导入类库</span><br><span class="hljs-keyword">import</span> queue<br><span class="hljs-comment"># 2、创建Queue</span><br>q = queue.Queue()<br><span class="hljs-comment"># 3、添加元素</span><br>q.put(item)<br><span class="hljs-comment"># 4、获取元素</span><br>item = q.get()<br><span class="hljs-comment"># 5、查询状态</span><br><span class="hljs-comment"># 查看元素的多少</span><br>q.qsize()<br><span class="hljs-comment"># 判断是否为空</span><br>q.empty()<br><span class="hljs-comment"># 判断是否已满</span><br>q.full()<br></code></pre></td></tr></table></figure></li><li><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> queue<br><span class="hljs-keyword">import</span> random,time<br><br><span class="hljs-comment"># 传入 url 队列 和 Html 队列</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_craw</span>(<span class="hljs-params">url_queue: queue.Queue, html_queue: queue.Queue</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 从 Url 队列里获取一个链接</span><br>        url = url_queue.get()<br>        html = blog_spider.craw(url)<br>        <span class="hljs-comment"># 将获取到的 html 内容放入 html 队列</span><br>        html_queue.put(html)<br>        <span class="hljs-comment"># current_thead: 当前线程 .name: 获取线程的名字</span><br>        <span class="hljs-built_in">print</span>(threading.current_thread().name, <span class="hljs-string">f&quot;craw <span class="hljs-subst">&#123;url&#125;</span>&quot;</span>,<br>              <span class="hljs-string">&quot;url_queue.size=&quot;</span>, url_queue.qsize())<br>        time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_parse</span>(<span class="hljs-params">html_queue: queue.Queue, fout</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        html = html_queue.get()<br>        results = blog_spider.parse(html)<br>        <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:<br>            fout.write(<span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;\n&quot;</span>)<br>        <span class="hljs-built_in">print</span>(threading.current_thread().name, <span class="hljs-string">f&quot;results.size&quot;</span>, <span class="hljs-built_in">len</span>(results),<br>              <span class="hljs-string">&quot;html_queue.size=&quot;</span>, html_queue.qsize())<br>        time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    url_queue = queue.Queue() <span class="hljs-comment"># 链接队列</span><br>    html_queue = queue.Queue() <span class="hljs-comment"># Html 文件队列</span><br>    <span class="hljs-comment"># 将所有链接添加到链接队列里面</span><br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br>        url_queue.put(url)<br><br>    <span class="hljs-comment"># 创建链接访问线程</span><br>    <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        t = threading.Thread(target=do_craw, args=(url_queue, html_queue),<br>                             name=<span class="hljs-string">f&quot;craw<span class="hljs-subst">&#123;idx&#125;</span>&quot;</span>)<br>        t.start()<br><br>    <span class="hljs-comment"># 创建 HTML 解析线程</span><br>    fout = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;02.data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br>    <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        <span class="hljs-comment"># name: 设置线程的名字.</span><br>        t = threading.Thread(target=do_parse, args=(html_queue, fout),<br>                             name=<span class="hljs-string">f&quot;parse<span class="hljs-subst">&#123;idx&#125;</span>&quot;</span>)<br>        t.start()<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-多进程-MultiProcess"><a href="#2-多进程-MultiProcess" class="headerlink" title="2. 多进程 (MultiProcess)"></a>2. 多进程 (MultiProcess)</h2><h3 id="全局解释器锁-Python的大缺点"><a href="#全局解释器锁-Python的大缺点" class="headerlink" title="全局解释器锁 (Python的大缺点)"></a>全局解释器锁 (Python的大缺点)</h3><ol><li><strong>任何时刻仅有一个线程</strong>在执行。</li><li>在<strong>多核心处理器上</strong>，使用 GIL 的解释器也只允许同一时间执行一个线程</li><li>GIL目的：为了解决多线程之间<strong>数据完整性</strong>和状态同步问题</li><li>GIL带来的<strong>问题</strong></li></ol><ul><li>即使使用了多线程，同一时刻也只有<strong>单个线程使用CPU</strong>，导致多核CPU的浪费</li><li>GIL只会对<strong>CPU密集型</strong>的程序产生影响</li><li>如果程序主要是在做<strong>I&#x2F;O操作</strong>，比如<strong>处理网络连接</strong>，那么<strong>多线程技术</strong>常常是一个明智的选择</li></ul><ol start="5"><li><strong>规避GIL</strong>的方法</li></ol><ul><li>规避方法2： 使用<code>multiprocessing</code>多进程，对CPU密集型计算，单独启动子进程解释器去执行</li><li>规避方法2： ﻿将计算密集型的任务转移到<strong>C语言</strong>中，因为C语言比Python快得多，注意要在C语言中自己释放GIL</li></ul><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210701000441.png"></p><blockquote><h3 id="多进程适用于-CPU密集型计算"><a href="#多进程适用于-CPU密集型计算" class="headerlink" title="多进程适用于 CPU密集型计算"></a>多进程适用于 CPU密集型计算</h3><p>多进程的API与 <strong>多线程的实现十分类似</strong></p></blockquote><table><thead><tr><th align="left">语法条目</th><th align="center">多线程</th><th align="center">多进程</th></tr></thead><tbody><tr><td align="left">引入模块</td><td align="center">from threading import Thread</td><td align="center">from multiprocessing import Process</td></tr><tr><td align="left">新建  启动  等待结束</td><td align="center">t&#x3D;Thread(target&#x3D;func, args&#x3D;(100, ))  t.start()  t.join()</td><td align="center">p &#x3D; Process(target&#x3D;f, args&#x3D;(‘bob’,))  p.start()  p.join()</td></tr><tr><td align="left">数据通信</td><td align="center">import queue  q &#x3D; queue.Queue()  q.put(item)  item &#x3D; q.get()</td><td align="center">from multiprocessing import Queue  q &#x3D; Queue()  q.put([42, None, ‘hello’])  item &#x3D; q.get()</td></tr><tr><td align="left">线程安全加锁</td><td align="center">from threading import Lock  lock &#x3D; Lock()  with lock:      # do something</td><td align="center">from multiprocessing import Lock  lock &#x3D; Lock()  with lock:      # do something</td></tr><tr><td align="left">池化技术</td><td align="center">from concurrent.futures import  ThreadPoolExecutor    with ThreadPoolExecutor() as executor:      # 方法1      results &#x3D; executor.map(func, [1,2,3])        # 方法2      future &#x3D; executor.submit(func, 1)      result &#x3D; future.result()</td><td align="center">from concurrent.futures import ProcessPoolExecutor    with ProcessPoolExecutor() as executor:      # 方法1      results &#x3D; executor.map(func, [1,2,3])        # 方法2      future &#x3D; executor.submit(func, 1)      result &#x3D; future.result()</td></tr></tbody></table><h3 id="利用进程池技术实现多进程"><a href="#利用进程池技术实现多进程" class="headerlink" title="利用进程池技术实现多进程"></a><strong>利用进程池技术实现多进程</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ProcessPoolExecutor<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">lover</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我喜欢:&quot;</span>, lover)<br>    time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 任何池化技术都需要写程序入口</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 喜欢的人列表</span><br>    lovers = [<span class="hljs-string">&quot;颖怡&quot;</span>, <span class="hljs-string">&quot;菲菲&quot;</span>, <span class="hljs-string">&quot;詹天佑&quot;</span>]<br>    start_time = time.time()<br>    <span class="hljs-comment"># 1. 使用 map 方式提交</span><br>    <span class="hljs-keyword">with</span> ProcessPoolExecutor(max_workers=<span class="hljs-number">10</span>) <span class="hljs-keyword">as</span> pool:<br>        <span class="hljs-comment"># map 方式提交进程池需要传入函数名和多参数元组</span><br>        pool.<span class="hljs-built_in">map</span>(test, lovers)<br><br>    <span class="hljs-comment"># 2. 使用 submit 方式提交</span><br>    <span class="hljs-keyword">with</span> ProcessPoolExecutor() <span class="hljs-keyword">as</span> pool:<br>        <span class="hljs-comment"># 利用进程列表启动</span><br>        futures=[<br>            pool.submit(test,lover)<br>            <span class="hljs-keyword">for</span> lover <span class="hljs-keyword">in</span> lovers<br>        ]<br><br>    end_time = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cost Time:&quot;</span>, end_time-start_time)<br></code></pre></td></tr></table></figure><h2 id="3-并发锁-Concurrent-Lock"><a href="#3-并发锁-Concurrent-Lock" class="headerlink" title="3. 并发锁 (Concurrent Lock)"></a>3. 并发锁 (Concurrent Lock)</h2><blockquote><p><strong>线程安全</strong>指某个函数、函数库在<strong>多线程环境</strong>中被调用时，能够正确地处理多个线程之间的<strong>共享变量</strong>，使程序功能正确完成。</p><p>由于<strong>线程的执行随时会发生切换</strong>，就造成了不可预料的结果，出现<strong>线程不安全</strong>(简单来说就是程序串行)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210702130844.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-comment"># 实例化锁对象</span><br>lock = threading.Lock()<br><span class="hljs-comment"># 上锁</span><br>lock.locked()<br><span class="hljs-comment"># 释放锁</span><br>lock.release()<br></code></pre></td></tr></table></figure><h3 id="用法1-try-finally-模式"><a href="#用法1-try-finally-模式" class="headerlink" title="用法1:  try-finally 模式"></a>用法1:  <code>try-finally</code> 模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br>lock = threading.Lock()<br>lock.acquire()<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># do something</span><br><span class="hljs-keyword">finally</span>:<br>    lock.release()<br></code></pre></td></tr></table></figure><h3 id="用法2-with-模式-推荐这种方式"><a href="#用法2-with-模式-推荐这种方式" class="headerlink" title="用法2: with 模式  (推荐这种方式)"></a>用法2: <code>with</code> 模式  <strong>(推荐这种方式)</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br>lock = threading.Lock()<br><span class="hljs-keyword">with</span> lock:<br>    <span class="hljs-comment"># do something</span><br></code></pre></td></tr></table></figure><h3 id="什么时候需要上锁"><a href="#什么时候需要上锁" class="headerlink" title="什么时候需要上锁"></a>什么时候需要上锁</h3><blockquote><p> <strong>多人读,不需要|一读一写要加|多人写要加</strong></p></blockquote><p>只是操作<strong>共享变量</strong>部分的代码要<strong>上锁</strong>,而不是多线程中所有代码都要上锁,并<strong>不影响多线程</strong>的执行效果.</p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210702143102.png" alt="image-20210702143100587"></p><h2 id="4-异步协程"><a href="#4-异步协程" class="headerlink" title="4. 异步协程"></a>4. 异步协程</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>同步：执行 IO 操作时，<strong>必须等待执行完成才得到返回结果</strong>。<br>异步：执行 IO 操作时，<strong>不必等待执行就能得到返回结果</strong>。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210702150837.jpeg"></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210702143833.png" alt="image-20210702143832079"></p><blockquote><p>注意：要用在<strong>异步IO编程中</strong>,依赖的<strong>库必须支持异步IO特性.</strong></p><p>爬虫引用中：<code>requests</code> 不支持异步|需要用 <code>aiohttp</code></p></blockquote><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="1-什么是协程、异步"><a href="#1-什么是协程、异步" class="headerlink" title="1. 什么是协程、异步"></a>1. 什么是协程、异步</h4><p>举个例子：假设有1个洗衣房，里面有10台洗衣机，有一个洗衣工在负责这10台洗衣机。那么<strong>洗衣房就相当于1个进程</strong>，洗衣工就相当<strong>1个线程</strong>。如果有10个洗衣工，就相当于<strong>10个线程</strong>，<strong>1个进程是可以开多线程的</strong>。这就是多线程！</p><p>那么协程呢？先不急。大家都知道，洗衣机洗衣服是<strong>需要等待时间</strong>的，如果10个洗衣工，1人负责1台洗衣机，这样效率肯定会提高，但是不觉得<strong>浪费资源</strong>吗？明明1 个人能做的事，却要10个人来做。只是把衣服放进去，打开开关，<strong>就没事做</strong>了，等衣服洗好再拿出来就可以了。就算很多人来洗衣服，<strong>1个人也足以应付了</strong>，开好第一台洗衣机，在等待的时候去<strong>开第二台洗衣机，再开第三台</strong>，……直到有衣服洗好了，就回来把衣服取出来，接着<strong>再取另一台</strong>的（哪台洗好先就取哪台，所以<strong>协程是无序的</strong>）。这就是计算机的协程！洗衣机就是<strong>执行的方法</strong>。</p><p>当你程序中方法需要等待时间的话，就可以用<strong>协程</strong>，<strong>效率高，消耗资源少。</strong></p><p><strong>洗衣房 &#x3D;&#x3D;&gt; 进程 | 洗衣工 &#x3D;&#x3D;&gt; 线程 | 洗衣机 &#x3D;&#x3D;&gt; 方法(函数)</strong></p><h4 id="2-async-await的使用"><a href="#2-async-await的使用" class="headerlink" title="2. async \ await的使用"></a>2. <code>async</code> \ <code>await</code>的使用</h4><p>正常的函数在执行时是<strong>不会中断</strong>的，所以你要写一个<strong>能够中断</strong>的函数，就需要添加<code>async</code>关键字。</p><p><code>async</code> 用来声明一个函数为异步函数，异步函数的特点是<strong>能在函数执行过程中挂起，去执行其他异步函数</strong>，等到<strong>挂起条件</strong>（假设挂起条件是sleep(5)）消失后，也就是5秒到了<strong>再回来执行</strong>。</p><p><code>await</code> 用来用来声明<strong>程序挂起</strong>，比如异步程序执行到<strong>某一步时需要等待的时间很长，就将此挂起</strong>，去<strong>执行其他的异步程序</strong>。<code>await</code> 后面只能跟 <strong>异步函数</strong> 或有<code>__await__</code>属性的对象，因为<strong>异步程序与一般程序不同</strong>。</p><p>假设有两个异步函数<code>async a，async b</code>，a中的某一步有<code>await</code>，当程序碰到关键字<code>await b()</code>后，异步程序挂起后去执行另一个异步b程序，就是从<strong>函数内部跳出去执行其他函数</strong>，<strong>当挂起条件消失后，不管b是否执行完，要马上从b程序中跳出来</strong>，<strong>回到原程序执行原来</strong>的操作。如果await后面跟的<strong>b函数不是异步函数</strong>，那么操作就<strong>只能等b执行完再返回</strong>，无法在<strong>b执行的过程中返回</strong>。如果要在<strong>b执行完</strong>才返回，也就<strong>不需要用await关键字了</strong>，直接<strong>调用b函数</strong>就行。所以这就需要<code>await</code>后面跟的是<strong>异步函数</strong>了。在一个异步函数中，可以<strong>不止一次挂起</strong>，也就是可以用多个<code>await</code>。</p><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现:"></a><strong>基本实现:</strong></h3><blockquote><ul><li><ol><li>在普通的函数前面加 <strong>async</strong> 关键字；</li></ol></li><li><ol start="2"><li><code>await</code> 表示在这个地方<strong>等待子函数执行完成</strong>，再往下执行。（在并发操作中，把程序控制权交给主程序，让他分配其他协程执行。） <code>await</code> 只能在带有 <code>async</code> 关键字的函数中运行。</li></ol></li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 异步io简单实现</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><span class="hljs-comment"># 获取超级事件循环</span><br><span class="hljs-comment"># event:事件 loop:环</span><br>loop = asyncio.get_event_loop()<br>urls = [<br>    <span class="hljs-string">f&quot;https://skyxinye.xyz/#<span class="hljs-subst">&#123;page&#125;</span>&quot;</span><br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">99</span>)<br>]<br><br><span class="hljs-comment"># 定义协程函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-keyword">await</span> time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 这样写不行,因为 time.sleep 不是异步函数,不能中途跳出执行另一个协程.</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment"># 用协程函数.</span><br><span class="hljs-comment"># 创建 task 列表</span><br><span class="hljs-comment"># create:创造</span><br>tasks = [<br>    <span class="hljs-comment"># 在超级循环中创造多个任务,并设置等待任务完成.(如果协程函数中没有同步操作的话就不用设置)</span><br>    <span class="hljs-comment"># 任务没有运行</span><br>    loop.create_task(asyncio.wait(myfunc(url)))<br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls<br>]<br><span class="hljs-comment"># 执行异步事件列表,运行直到完成,如果是协程列表就要设置等待事件完成.</span><br>loop.run_until_complete(asyncio.wait(tasks))<br></code></pre></td></tr></table></figure><h4 id="利用-aiohttp-模块发送网络请求"><a href="#利用-aiohttp-模块发送网络请求" class="headerlink" title="利用 aiohttp 模块发送网络请求"></a>利用 <code>aiohttp</code> 模块发送网络请求</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 异步模块 aiohttp 使用</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> aiohttp<br><br><br><span class="hljs-comment"># Http请求 协程函数</span><br><span class="hljs-comment"># GET</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">async_get</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    aiohttp:发送http请求</span><br><span class="hljs-string">    1.创建一个ClientSession对象</span><br><span class="hljs-string">    2.通过ClientSession对象去发送请求（get, post, delete等）</span><br><span class="hljs-string">    3.await 异步等待返回结果</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Get Url:&quot;</span>, url)<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> se:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> se.get(url) <span class="hljs-keyword">as</span> resp:<br>            result = <span class="hljs-keyword">await</span> resp.text()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(result))<br><br>urls = [<br>    <span class="hljs-string">f&quot;https://skyxinye.xyz/#<span class="hljs-subst">&#123;page&#125;</span>&quot;</span><br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">99999</span>)<br>]<br><br><span class="hljs-comment"># 超级循环</span><br>loop = asyncio.get_event_loop()<br><span class="hljs-comment"># 事件列表</span><br>tasks=[<br>    loop.create_task(async_get(url))<br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls <br>]<br><span class="hljs-comment"># 用 wait 方法遍历事件列表.协程列表需要设置等待运行完成</span><br>loop.run_until_complete(asyncio.wait(tasks))<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    异步协程不用事件列表的另一种实现方法</span><br><span class="hljs-string">    aiohttp:发送POST请求</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># POST</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    data = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br>    url = <span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(url, data=data) <span class="hljs-keyword">as</span> res:<br>            <span class="hljs-built_in">print</span>(res.status)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> res.text())<br>loop = asyncio.get_event_loop()<br><span class="hljs-comment"># 如果是单个协程就不需要设置 asyncio.wait()</span><br>task = loop.create_task(main())<br>loop.run_until_complete(task)<br></code></pre></td></tr></table></figure><h4 id="利用-aiofile-异步操作文件"><a href="#利用-aiofile-异步操作文件" class="headerlink" title="利用 aiofile 异步操作文件"></a>利用 <code>aiofile</code> 异步操作文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiofiles<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiofiles.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,encoding=<span class="hljs-string">&quot;utf8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>        <span class="hljs-keyword">await</span> fp.write(<span class="hljs-string">&quot;异步写入文件&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件写入成功&quot;</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiofiles.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&quot;utf8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>        content = <span class="hljs-keyword">await</span> fp.read()<br>        <span class="hljs-built_in">print</span>(content)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read2_demo</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiofiles.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;text.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>        <span class="hljs-comment"># 读取每行</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> fp:<br>            <span class="hljs-built_in">print</span>(line)<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(write())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抑郁症用药大全对照表</title>
    <link href="/2021/06/18/depression-medicine/"/>
    <url>/2021/06/18/depression-medicine/</url>
    
    <content type="html"><![CDATA[<h1 id="抑郁症常用药物对照表"><a href="#抑郁症常用药物对照表" class="headerlink" title="抑郁症常用药物对照表"></a>抑郁症常用药物对照表</h1><blockquote><h2 id="利用-Python-爬取-项目地址-AdminWhaleFall-x2F-MyCuteGirl-x2F"><a href="#利用-Python-爬取-项目地址-AdminWhaleFall-x2F-MyCuteGirl-x2F" class="headerlink" title="利用 Python 爬取,项目地址:AdminWhaleFall&#x2F;MyCuteGirl&#x2F;"></a>利用 Python 爬取,项目地址:<a href="https://github.com/AdminWhaleFall/MyCuteGirl/">AdminWhaleFall&#x2F;MyCuteGirl&#x2F;</a></h2></blockquote><table><thead><tr><th align="center">药物名称(俗名)</th><th>主治</th></tr></thead><tbody><tr><td align="center">圣·约翰草提取物片(路优泰)</td><td>抑郁症，焦虑和&#x2F;或烦躁不安。</td></tr><tr><td align="center">马来酸氟伏沙明片(兰释)</td><td>抑郁发作。强迫症(OCD)。</td></tr><tr><td align="center">盐酸氟西汀分散片(百优解)</td><td>抑郁症强迫症(OCD)神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为 中度至重度抑郁发作：8岁及以上的儿童和青少年强迫症：7岁及以上的儿童和青少年</td></tr><tr><td align="center">劳拉西泮片(罗拉)</td><td>适用于焦虑障碍的治疗或用于缓解焦虑症状以及与抑郁症状相关的焦虑的短期治疗。与日常生活压力相关的焦虑或紧张，通常不需要抗焦虑药的治疗。劳拉西泮长期应用的效果即应用4个月以上的效果还未经系统的临床研究评估。医师应定期重新评估该药对个体患者的有效性。</td></tr><tr><td align="center">阿戈美拉汀片(维度新)</td><td>治疗成人抑郁症。本品适用于成人。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期 预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经 痛以及疱疹后神经痛。预防或治疗躁狂-抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症， 可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr><tr><td align="center">米氮平片(瑞美隆®)</td><td>抑郁症的发作</td></tr><tr><td align="center">盐酸度洛西汀肠溶胶囊(欣百达)</td><td>用于治疗抑郁症； 用于治疗广泛性焦虑障碍； 用于治疗慢性肌肉骨骼疼痛。</td></tr><tr><td align="center">氢溴酸西酞普兰片(氢溴酸西酞普兰片)</td><td>治疗抑郁症。</td></tr><tr><td align="center">噻奈普汀钠片(达体朗)</td><td>抑郁发作(即典型性)。</td></tr><tr><td align="center">圣·约翰草提取物片(路优泰)</td><td>抑郁症，焦虑和&#x2F;或烦躁不安。</td></tr><tr><td align="center">马来酸氟伏沙明片(兰释)</td><td>抑郁发作。强迫症(OCD)。</td></tr><tr><td align="center">盐酸氟西汀分散片(百优解)</td><td>抑郁症强迫症(OCD)神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为 中度至重度抑郁发作：8岁及以上的儿童和青少年强迫症：7岁及以上的儿童和青少年</td></tr><tr><td align="center">劳拉西泮片(罗拉)</td><td>适用于焦虑障碍的治疗或用于缓解焦虑症状以及与抑郁症状相关的焦虑的短期治疗。与日常生活压力相关的焦虑或紧张，通常不需要抗焦虑药的治疗。劳拉西泮长期应用的效果即应用4个月以上的效果还未经系统的临床研究评估。医师应定期重新评估该药对个体患者的有效性。</td></tr><tr><td align="center">阿戈美拉汀片(维度新)</td><td>治疗成人抑郁症。本品适用于成人。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期 预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经 痛以及疱疹后神经痛。预防或治疗躁狂-抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症， 可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr><tr><td align="center">米氮平片(瑞美隆®)</td><td>抑郁症的发作</td></tr><tr><td align="center">盐酸度洛西汀肠溶胶囊(欣百达)</td><td>用于治疗抑郁症； 用于治疗广泛性焦虑障碍； 用于治疗慢性肌肉骨骼疼痛。</td></tr><tr><td align="center">氢溴酸西酞普兰片(氢溴酸西酞普兰片)</td><td>治疗抑郁症。</td></tr><tr><td align="center">噻奈普汀钠片(达体朗)</td><td>抑郁发作(即典型性)。</td></tr><tr><td align="center">盐酸阿米替林片(阿密替林)</td><td>用于治疗各种抑郁症，本品的镇静作用较强，主要用于治疗焦虑性或激动性抑郁症。</td></tr><tr><td align="center">盐酸帕罗西汀片(赛乐特)</td><td>本品用于治疗抑郁症、强迫症、伴有或不伴有广场恐怖的惊恐障碍、社交恐怖症&#x2F;社交焦虑症。 疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。</td></tr><tr><td align="center">盐酸文拉法辛缓释胶囊(怡诺思)</td><td>本品用于治疗抑郁症（包括伴有焦虑的抑郁症）及广泛性焦虑障碍。</td></tr><tr><td align="center">草酸艾司西酞普兰片(来士普)</td><td>治疗抑郁症。治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr><tr><td align="center">盐酸舍曲林片(左洛复)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 舍曲林也用于治疗强迫症。疗效满意后，继续服用舍曲林可有效地防止强迫症初始症状的复发。</td></tr><tr><td align="center">阿戈美拉汀片(维度新)</td><td>治疗成人抑郁症。br&#x2F;&gt;br&#x2F;&gt;本品适用于成人。</td></tr><tr><td align="center">盐酸度洛西汀肠溶胶囊(欣百达)</td><td>用于治疗抑郁症；br&#x2F;&gt;br&#x2F;&gt;用于治疗广泛性焦虑障碍。</td></tr><tr><td align="center">盐酸帕罗西汀肠溶缓释片(赛乐特)</td><td>用于治疗成人抑郁症。 在两项对符合美国精神障碍诊断统计手册（第四版）标准的抑郁症门诊患者进行的12周对照临床试验中，确立了盐酸帕罗西汀肠溶缓释片治疗抑郁症发作的有效性。尚未充分研究帕罗西汀对住院抑郁患者的抗抑郁作用。尚未在对照临床试验中对帕罗西汀肠溶缓释片超过12周的疗效安全性进行系统的评价；可是，在对照临床试验中证实了帕罗西汀速释片对抑郁症患者的长达1年维持治疗的有效性（参见【临床试验】）。 医生如果选择帕罗西汀肠溶缓释片进行长期治疗，应该定期对药物用于个体患者的长期有效性进行再评估。</td></tr><tr><td align="center">盐酸氟西汀胶囊(艾旭)</td><td>各种抑郁性精神障碍、包括轻性或重性抑郁症、双相情感性精神障碍的抑郁症，心因性抑郁及抑郁性神经症。</td></tr><tr><td align="center">米氮平口腔崩解片(瑞美隆®)</td><td>抑郁症的发作。对症状如快感缺乏，精神运动性抑制，睡眠欠佳（早醒），以及体重减轻均有疗效。也可用于其它症状如：对事物丧失兴趣，自杀念头以及情绪波动（早上好，晚上差）。本药在用药1-2周后起效。</td></tr><tr><td align="center">盐酸文拉法辛胶囊(博乐欣)</td><td>抑郁症。</td></tr><tr><td align="center">盐酸多塞平片(多虑平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr><tr><td align="center">氢溴酸西酞普兰片(氢溴酸西酞普兰片)</td><td>各种类型的抑郁症。</td></tr><tr><td align="center">米氮平片(瑞美隆)</td><td>用于抑郁症的治疗。</td></tr><tr><td align="center">盐酸帕罗西汀片(乐友)</td><td>治疗各种类型的抑郁症。包括伴有焦虑的抑郁症及反应性抑郁症。常见的抑郁症状：乏力，睡眠障碍，对日常活动缺乏兴趣和愉悦感，食欲减退。治疗强迫性神经症。常见的强迫症状：感受反复和持续的可引起明显焦虑的思想、冲动或想象，从而导致重复的行为或心理活动。治疗伴有或不伴有广场恐怖的惊恐障碍。常见的惊恐发作症状：心悸，出汗，气短，胸痛，恶心，麻刺感和濒死感。治疗社交恐怖症&#x2F;社交焦虑症。常见的社交焦虑的症状：心悸，出汗，气短等。通常表现为继发于显著或持续的对一个或多个社交情景或表演场合的畏惧，从而导致回避。治疗疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。</td></tr><tr><td align="center">米氮平片(派迪生)</td><td>抑郁症。</td></tr><tr><td align="center">氢溴酸西酞普兰片(喜普妙)</td><td>治疗抑郁症。</td></tr><tr><td align="center">草酸艾司西酞普兰片(百适可)</td><td>治疗抑郁症。治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr><tr><td align="center">盐酸帕罗西汀片(舒坦罗)</td><td>本品用于治疗抑郁症、强迫症、伴有或不伴有广场恐怖的惊恐障碍、社交恐怖症&#x2F;社交焦虑症。 疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。</td></tr><tr><td align="center">盐酸度洛西汀肠溶片(奥思平)</td><td>用于治疗抑郁症。</td></tr><tr><td align="center">盐酸氟西汀胶囊(优克)</td><td>各种抑郁性精神障碍，包括轻性或重性抑郁症、双相情感性精神障碍的抑郁症，心因性抑郁及抑郁性神经症。 中度至重度抑郁发作：8岁及以上的儿童和青少年强迫症：7岁及以上的儿童和青少年</td></tr><tr><td align="center">盐酸氟西汀片(开克)</td><td>各种抑郁性精神障碍。包括轻性或重性抑郁症,双相情感性精神障碍的抑郁相,心因性抑郁及抑郁性神经症。 中度至重度抑郁发作：8岁及以上的儿童和青少年强迫症：7岁及以上的儿童和青少年</td></tr><tr><td align="center">吗氯贝胺片(吗氯贝胺片)</td><td>抑郁症。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕</td></tr><tr><td align="center">盐酸氟西汀胶囊(奥麦伦)</td><td>各种抑郁性精神障碍、包括轻性或重性抑郁症、双相情感性精神障碍的抑郁症，心因性抑郁及抑郁性神经症。 中度至重度抑郁发作：8岁及以上的儿童和青少年强迫症：7岁及以上的儿童和青少年</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">盐酸氟西汀胶囊(百优解)</td><td>抑郁症; 强迫症; 神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其它用途有止呕。</td></tr><tr><td align="center">盐酸阿米替林片(盐酸阿米替林片)</td><td>用于治疗各种抑郁症，本品的镇静作用较强，主要用于治疗焦虑性或激动性抑郁症。</td></tr><tr><td align="center">盐酸舍曲林片(快五优)</td><td>盐酸舍曲林用于治疗抑郁症的相关症状.包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用盐酸舍曲林可有效地防止抑郁症的复发和再发。盐酸舍曲林也用于治疗强迫症，初始治疗有反应后，盐酸舍曲林在治疗强迫症二年的时间内、仍保持它的有效性，安全性和耐受性。</td></tr><tr><td align="center">盐酸氟西汀肠溶片(金开克)</td><td>本品适用于抑郁症缓解期，用于巩固期治疗和维持期疗效。</td></tr><tr><td align="center">盐酸马普替林片(路滴美)</td><td>抑郁症内源性抑郁症，迟发性抑郁症（更年期性抑郁症）。精神性抑郁症，反应性和神经性抑郁症、耗竭性抑郁症。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>复杂部分性发作 (亦称精神运动性发作或颞叶癫癎)、全身强直-阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂-抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。不宁腿综合征 (Ekbom综合征)，偏侧面肌痉孪。酒精癖的戒断综合征。</td></tr><tr><td align="center">盐酸多塞平片(盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">甲磺酸瑞波西汀胶囊(甲磺酸瑞波西汀胶囊)</td><td>用于治疗成人抑郁症。</td></tr><tr><td align="center">氯普噻吨片(氯普噻吨片)</td><td>用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。</td></tr><tr><td align="center">盐酸甲氯芬酯胶囊(特维知®)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>1、癫痫：部分性发作：复杂部分性发作。全身性发作：强直、阵挛、强直阵挛发作。 2、三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 3、预防或治疗躁狂-抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。 4、中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 5、酒精癖的戒断综合征。</td></tr><tr><td align="center">阿戈美拉汀片(阿美宁)</td><td>治疗成人抑郁症。本品适用于成人。</td></tr><tr><td align="center">盐酸米安色林片(盐酸米安色林片)</td><td>适用于药物治疗的各型抑郁症患者，能解除其抑郁症状。</td></tr><tr><td align="center">盐酸氯米帕明注射液(氯丙米嗪)</td><td>用于治疗严重抑郁症及难治性抑郁症。</td></tr><tr><td align="center">盐酸安非他酮片(乐孚亭)</td><td>用于治疗抑郁症。</td></tr><tr><td align="center">甲磺酸瑞波西汀片(甲磺酸瑞波西汀片)</td><td>用于治疗成人抑郁症。</td></tr><tr><td align="center">盐酸文拉法辛缓释片(盐酸文拉法辛缓释片)</td><td>本品适用于治疗各种类型抑郁症（包括伴有焦虑的抑郁症）及广泛性焦虑症。</td></tr><tr><td align="center">甲磺酸瑞波西汀片(佐乐辛)</td><td>用于治疗成人抑郁症。</td></tr><tr><td align="center">盐酸舍曲林片(唯他停)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。</td></tr><tr><td align="center">米氮平片(米尔宁)</td><td>用于抑郁症的治疗。</td></tr><tr><td align="center">氢溴酸西酞普兰片(迈克伟)</td><td>各种类型的抑郁症。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>1．癫痫： （1）部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。 （2）全身性发作：强直、阵挛、强直阵挛发作。 2．三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。3．预防或治疗躁狂-抑郁症：对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。 4．中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 5．酒精癖的戒断综合征。</td></tr><tr><td align="center">匹莫林片(匹莫林片)</td><td>用于治疗儿童多动症、轻度抑郁症及发作性睡病。也可用于遗传性过敏性皮炎。</td></tr><tr><td align="center">莫达非尼片(莫达非尼片)</td><td>抑郁症患者。特发性嗜睡或发作性睡眠症</td></tr><tr><td align="center">盐酸多塞平片(盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr><tr><td align="center">盐酸多塞平片(盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr><tr><td align="center">盐酸舍曲林片(乐元)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林片(西同静)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸多塞平片(盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr><tr><td align="center">马来酸氟伏沙明片(瑞必乐)</td><td>抑郁症及相关症状的治疗 ；强迫症症状的治疗。</td></tr><tr><td align="center">氯普噻吨片(氯普噻吨片)</td><td>用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。</td></tr><tr><td align="center">阿普唑仑胶囊(阿普唑仑胶囊)</td><td>催眠镇静药。适用于治疗焦虑症、抑郁症、失眠、恐惧。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">碳酸锂缓释片(碳酸锂缓释片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂-情感性精神病。</td></tr><tr><td align="center">碳酸锂片(碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂-情感性精神病。</td></tr><tr><td align="center">氯普噻吨片(氯普噻吨片)</td><td>用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">碳酸锂片(碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂-情感性精神病。</td></tr><tr><td align="center">碳酸锂片(碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂-情感性精神病。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>（1）癫癎：部分性发作，复杂部分性发作，简单部分性发作和继发性全身发作，全身性发作，全身性发作，强直、阵挛、强直阵挛发作。 （2）三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 （3）预防或治疗躁狂-抑郁症；对锂或抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。 （4）中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 （5）酒精癖的戒断综合征。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。 全身性发作：强直、阵挛、强直阵挛发作。 三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 预防或治疗躁狂一抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂一抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 酒精癖的戒断综合征。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。 三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 预防或治疗躁狂-抑郁症：对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 酒精癖的戒断综合征。</td></tr><tr><td align="center">卡马西平片(宁新宝)</td><td>（1）癫痫：部分性发作：复杂部分性发作、简单部分发作和继发性全身发作。全身性发作：强直、阵挛、强制性挛发作。 （2）三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 （3）预防或治疗躁狂-抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。 （4）中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 （5）酒精癖的戒断综合征。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>1.癫痫。部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。 2.三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 3.预防或治疗躁狂-抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。 4.中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 5.酒精癖的戒断综合征。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>1.癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。 2.三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 3.预防或治疗躁狂-抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。 4.中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 5.酒精癖的戒断综合征。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">卡马西平胶囊(卡马西平胶囊)</td><td>复杂部分性发作 (亦称精神运动性发作或颞叶癫痫)、全身强直-阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂-抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。 不宁腿综合症（Ekbom综合征），偏侧面肌痉孪。 酒精癖的戒断综合征。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>（1）复杂部分性发作（亦称精神运动性发作或颞叶癫痫）、全身强直-阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。 （2）三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 （3）预防或治疗躁狂-抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。 （4）中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 （5）对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。 （6）不宁腿综合征（Ekbom综合征），偏侧面肌痉孪。 （7）酒精癖的戒断综合征。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>复杂部分性发作（亦称精神运动性发作或颞叶癫癎）、全身强直-阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。 三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 预防或治疗躁狂-抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。 不宁腿综合征（Ekbom综合征），偏侧面肌痉挛。 酒精癖的戒断综合征。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>复杂部分性发作（亦称精神运动性发作或颞叶癫痫）、全身强直-阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。 三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 预防或治疗躁狂-抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。 不宁腿综合征（Ekbom综合征），偏侧面肌痉孪。 酒精癖的戒断综合征。</td></tr><tr><td align="center">盐酸舍曲林分散片(盐酸舍曲林分散片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑，有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用治疗强迫症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。</td></tr><tr><td align="center">吗氯贝胺片(恬泰)</td><td>抑郁症。</td></tr><tr><td align="center">吗氯贝胺片(亚正)</td><td>抑郁症</td></tr><tr><td align="center">米氮平片(派迪生)</td><td>抑郁症。</td></tr><tr><td align="center">吗氯贝胺胶囊(贝苏)</td><td>抑郁症。</td></tr><tr><td align="center">盐酸氯米帕明注射液(盐酸氯米帕明注射液)</td><td>用于治疗严重抑郁症及难治性抑郁症。</td></tr><tr><td align="center">盐酸米那普仑片(盐酸米那普仑片)</td><td>治疗抑郁症。</td></tr><tr><td align="center">氢溴酸西酞普兰胶囊(多弗)</td><td>治疗抑郁症。</td></tr><tr><td align="center">氢溴酸西酞普兰片(一泰纳)</td><td>治疗抑郁症。</td></tr><tr><td align="center">氢溴酸西酞普兰口服溶液(氢溴酸西酞普兰口服溶液)</td><td>各种类型的抑郁症。</td></tr><tr><td align="center">盐酸安非他酮缓释片(盐酸安非他酮缓释片)</td><td>用于治疗抑郁症。</td></tr><tr><td align="center">盐酸安非他酮片(盐酸安非他酮片)</td><td>用于治疗抑郁症。</td></tr><tr><td align="center">氢溴酸西酞普兰片(望悠)</td><td>各种类型的抑郁症。</td></tr><tr><td align="center">氢溴酸西酞普兰片(氢溴酸西酞普兰片)</td><td>各种类型的抑郁症。</td></tr><tr><td align="center">盐酸安非他酮缓释片(盐酸安非他酮缓释片)</td><td>用于治疗抑郁症。</td></tr><tr><td align="center">盐酸安非他酮缓释片(盐酸安非他酮缓释片)</td><td>用于治疗抑郁症。</td></tr><tr><td align="center">氢溴酸西酞普兰片(优乐喜)</td><td>各种类型的抑郁症。</td></tr><tr><td align="center">氢溴酸西酞普兰片(易特安)</td><td>各种类型的抑郁症。</td></tr><tr><td align="center">盐酸氟西汀胶囊(聚立能)</td><td>用于各种抑郁症的治疗。</td></tr><tr><td align="center">盐酸安非他酮缓释片(宏发)</td><td>用于治疗抑郁症。</td></tr><tr><td align="center">盐酸安非他酮片(盐酸安非他酮片)</td><td>用于治疗抑郁症。</td></tr><tr><td align="center">盐酸度洛西汀肠溶胶囊(奥思平)</td><td>用于治疗抑郁症。</td></tr><tr><td align="center">氢溴酸西酞普兰口服溶液(氢溴酸西酞普兰口服溶液)</td><td>各种类型的抑郁症。</td></tr><tr><td align="center">米氮平片(米尔宁®)</td><td>用于治疗抑郁症。</td></tr><tr><td align="center">氢溴酸西酞普兰片(望悠)</td><td>各种类型的抑郁症。</td></tr><tr><td align="center">氢溴酸西酞普兰片(氢溴酸西酞普兰片)</td><td>各种类型的抑郁症。</td></tr><tr><td align="center">米氮平片(米氮平片)</td><td>用于抑郁症的治疗。</td></tr><tr><td align="center">草酸艾司西酞普兰(草酸艾司西酞普兰)</td><td>治疗抑郁障碍</td></tr><tr><td align="center">盐酸安非他酮缓释片(盐酸安非他酮缓释片)</td><td>用于治疗抑郁症。</td></tr><tr><td align="center">氢溴酸西酞普兰片(特林那)</td><td>各种类型的抑郁症。</td></tr><tr><td align="center">盐酸度洛西汀肠溶胶囊(奥思平)</td><td>用于治疗抑郁症。</td></tr><tr><td align="center">甲磺酸瑞波西汀片(叶洛抒)</td><td>用于治疗成人抑郁症。</td></tr><tr><td align="center">噻奈普汀钠片(达体朗)</td><td>抑郁发作（即典型性）</td></tr><tr><td align="center">盐酸舍曲林片(盐酸舍曲林片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 舍曲林也用于治疗强迫症。疗效满意后，继续服用舍曲林可有效地防止强迫症初始症状的复发。</td></tr><tr><td align="center">盐酸文拉法辛胶囊(盐酸文拉法辛胶囊)</td><td>适用于各种类型抑郁症。</td></tr><tr><td align="center">盐酸文拉法辛胶囊(盐酸文拉法辛胶囊)</td><td>适用于各种类型抑郁症。</td></tr><tr><td align="center">盐酸文拉法辛胶囊(盐酸文拉法辛胶囊)</td><td>适用于各种类型抑郁症。</td></tr><tr><td align="center">噻奈普汀片(达体朗)</td><td>抑郁发作(即典型性)。</td></tr><tr><td align="center">盐酸文拉法辛胶囊(盐酸文拉法辛胶囊)</td><td>适用于治疗各种类型抑郁症。</td></tr><tr><td align="center">盐酸文拉法辛胶囊(盐酸文拉法辛胶囊)</td><td>适用于各种类型抑郁症</td></tr><tr><td align="center">盐酸文拉法辛胶囊(盐酸文拉法辛胶囊)</td><td>适用于各种类型抑郁症。</td></tr><tr><td align="center">盐酸文拉法辛胶囊(盐酸文拉法辛胶囊)</td><td>适用于各种类型抑郁症</td></tr><tr><td align="center">盐酸文拉法辛片(盐酸文拉法辛片)</td><td>适用于治疗各种类型抑郁症。</td></tr><tr><td align="center">吗氯贝胺片(吗氯贝胺片)</td><td>本品用于治疗抑郁症。</td></tr><tr><td align="center">盐酸安非他酮缓释片(Ⅱ)(盐酸安非他酮缓释片(Ⅱ))</td><td>本品用于治疗抑郁症。</td></tr><tr><td align="center">盐酸文拉法辛胶囊(盐酸文拉法辛胶囊)</td><td>适用于治疗各种类型抑郁症。</td></tr><tr><td align="center">氢溴酸伏硫西汀片(心达悦Brintellix)</td><td>本品用于治疗成人抑郁症。</td></tr><tr><td align="center">盐酸舍曲林胶囊(联环优定)</td><td>舍曲林用于治疗a class&#x3D;’J-redirect’ data-type&#x3D;’18’ data-id&#x3D;’127’ field-id&#x3D;’2325’&gt;抑郁症&#x2F;a&gt;的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。br&#x2F;&gt;br&#x2F;&gt;舍曲林也用于治疗a class&#x3D;’J-redirect’ data-type&#x3D;’18’ data-id&#x3D;’129’ field-id&#x3D;’2329’&gt;强迫症&#x2F;a&gt;，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林胶囊(盐酸舍曲林胶囊)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。br&#x2F;&gt;br&#x2F;&gt;舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸文拉法辛片(盐酸文拉法辛片)</td><td>适用于治疗各种类型抑郁症。</td></tr><tr><td align="center">盐酸舍曲林胶囊(愈朗)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。 疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林胶囊(郁洛欣)</td><td>​舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林分散片(盐酸舍曲林分散片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林片(盐酸舍曲林片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林片(盐酸舍曲林片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸文拉法辛胶囊(盐酸文拉法辛胶囊)</td><td>适用于治疗各种类型抑郁症。</td></tr><tr><td align="center">盐酸舍曲林片(申安)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林片(贝玉)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林片(盐酸舍曲林片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性，安全性和耐受性。</td></tr><tr><td align="center">盐酸多塞平片(盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr><tr><td align="center">盐酸舍曲林胶囊(盐酸舍曲林胶囊)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林胶囊(盐酸舍曲林胶囊)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林片(盐酸舍曲林片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林片(彼迈乐)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林片(应思调)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸舍曲林片(伊素明)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr><tr><td align="center">盐酸多塞平片(天平)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr><tr><td align="center">盐酸多塞平片(盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr><tr><td align="center">盐酸多塞平片(盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr><tr><td align="center">盐酸多塞平片(盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr><tr><td align="center">盐酸曲唑酮片(舒绪)</td><td>本品适用于抑郁症的治疗，对伴有或不伴有焦虑的患者均有效。</td></tr><tr><td align="center">盐酸曲唑酮片(宏发)</td><td>本品适用于抑郁症的治疗，对伴有或不伴有焦虑的患者均有效。</td></tr><tr><td align="center">盐酸氟西汀分散片(盐酸氟西汀分散片)</td><td>抑郁症、强迫症、神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为。 中度至重度抑郁发作：8岁及以上的儿童和青少年强迫症：7岁及以上的儿童和青少年</td></tr><tr><td align="center">盐酸马普替林片(盐酸马普替林片)</td><td>用于各型抑郁症。对精神分裂症后抑郁也有效。</td></tr><tr><td align="center">盐酸安非他酮缓释片(盐酸安非他酮缓释片)</td><td>1、用于治疗抑郁症。2、用于辅助戒烟。</td></tr><tr><td align="center">盐酸氟西汀分散片(盐酸氟西汀分散片)</td><td>抑郁症; 强迫症; 神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为。 中度至重度抑郁发作：8岁及以上的儿童和青少年强迫症：7岁及以上的儿童和青少年</td></tr><tr><td align="center">盐酸马普替林片(盐酸马普替林片)</td><td>用于各型抑郁症。对精神分裂症后抑郁也有效。</td></tr><tr><td align="center">草酸艾司西酞普兰片(百洛特)</td><td>治疗抑郁症。治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr><tr><td align="center">盐酸曲唑酮片(舒绪)</td><td>本品适用于抑郁症的治疗，对伴有或不伴有焦虑的患者均有效。</td></tr><tr><td align="center">盐酸帕罗西汀片(盐酸帕罗西汀片)</td><td>治疗各种类型的抑郁症，包括伴有焦虑的抑郁症及反应性抑郁症。常见的抑郁症状：乏力、睡眠障碍、对日常活动缺乏兴趣和愉悦感、食欲减退。治疗强迫性神经症。常见的强迫症状：感受反复和持续的可引起明显焦虑的思想、冲动或想象，从而导致重复的行为或心理活动。治疗伴有或不伴有广场恐怖的惊恐障碍。常见的惊恐发作症状：心悸、出汗、气短、胸痛、恶心、麻刺感和濒死感。治疗社交恐怖症&#x2F;社交焦虑症。常见的社交焦虑的症状：心悸、出汗、气短等。通常表现为继发于显著或持续的对一个或多个社交情景或表演场合的畏惧，从而导致回避。治疗疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。</td></tr><tr><td align="center">盐酸马普替林片(盐酸马普替林片)</td><td>用于各型抑郁症。对精神分裂症后抑郁也有效。</td></tr><tr><td align="center">草酸艾司西酞普兰片(草酸艾司西酞普兰片)</td><td>治疗抑郁症。治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr><tr><td align="center">盐酸度洛西汀肠溶胶囊(盐酸度洛西汀肠溶胶囊)</td><td>用于治疗抑郁症；用于治疗广泛性焦虑障碍。</td></tr><tr><td align="center">盐酸度洛西汀肠溶胶囊(盐酸度洛西汀肠溶胶囊)</td><td>抑郁症；广泛性焦虑障碍；慢性肌肉骨骼疼痛。</td></tr><tr><td align="center">富马酸喹硫平缓释片(富马酸喹硫平缓释片)</td><td>本品用于治疗精神分裂症和双相情感障碍的抑郁发作。</td></tr><tr><td align="center">盐酸帕罗西汀片(盐酸帕罗西汀片)</td><td>治疗各种类型的抑郁症，包括伴有焦虑的抑郁症及反应性抑郁症。常见的抑郁症状：乏力、睡眠障碍、对日常活动缺乏兴趣和愉悦感、食欲减退。治疗强迫性神经症。常见的强迫症状：感受反复和持续的可引起明显焦虑的思想、冲动或想象、从而导致重复的行为或心理活动。治疗伴有或不伴有广场恐怖的惊恐障碍。常见的惊恐发作症状：心悸、出汗、气短、胸痛、恶心、麻刺感和濒死感。治疗社交恐怖症&#x2F;社交焦虑症。常见的社交焦虑的症状：心悸、出汗、气短等。通常表现为继发于显著或持续的对一个或多个社交情景或表演场合的畏惧，从而导致回避。治疗疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。</td></tr><tr><td align="center">草酸艾司西酞普兰片(草酸艾司西酞普兰片)</td><td>治疗抑郁障碍，治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr><tr><td align="center">草酸艾司西酞普兰片(草酸艾司西酞普兰片)</td><td>治疗抑郁障碍，治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr><tr><td align="center">草酸艾司西酞普兰片(草酸艾司西酞普兰片)</td><td>治疗抑郁障碍，治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr><tr><td align="center">盐酸氟西汀胶囊(盐酸氟西汀胶囊)</td><td>抑郁发作。强迫症。精神性贪食症：可作为心理治疗的补充，用于减少贪食和导泻行为。</td></tr><tr><td align="center">氯普噻吨片(氯普噻吨片)</td><td>用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。</td></tr><tr><td align="center">氯普噻吨片(氯普噻吨片)</td><td>用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。</td></tr><tr><td align="center">富马酸喹硫平缓释片(思瑞康)</td><td>用于治疗精神分裂症。 用于双相情感障碍的抑郁发作。</td></tr><tr><td align="center">盐酸氯普噻吨注射液(盐酸氯普噻吨注射液)</td><td>用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。</td></tr><tr><td align="center">盐酸帕罗西汀肠溶缓释片(盐酸帕罗西汀肠溶缓释片)</td><td>用于治疗成人抑郁症。 在两项对符合美国精神障碍诊断统计手册（第四版）标准的抑郁症门诊患者进行的12周对照临床试验中，确立了盐酸帕罗西汀肠溶缓释片治疗抑郁症发作的有效性。尚未充分研究帕罗西汀对住院抑郁患者的抗抑郁作用。 尚未在对照临床试验中对帕罗西汀肠溶缓释片超过12周的疗效安全性进行系统的评价；可是，在对照临床试验中证实了帕罗西汀速释片对抑郁症患者的长达1年维持治疗的有效性（参见【临床试验】）。医生如果选择帕罗西汀肠溶缓释片进行长期治疗，应该定期对药物用于个体患者的长期有效性进行再评估。</td></tr><tr><td align="center">富马酸喹硫平缓释片(富马酸喹硫平缓释片)</td><td>本品用于治疗精神分裂症和双相情感障碍的抑郁发作。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其它用途有止呕。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">舒必利注射液(舒必利注射液)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">盐酸丙米嗪片(盐酸丙米嗪片)</td><td>用于各种抑郁症。因具有振奋作用，适用于迟钝型抑郁，但不宜用于激越型抑郁或焦虑性抑郁。亦可用于小儿遗尿症。</td></tr><tr><td align="center">巴戟天寡糖胶囊(巴戟天寡糖胶囊)</td><td>温补肾阳。用于轻中度抑郁症中医辨证属于肾阳虚证者，症见抑郁情绪、心绪低落、失眠多梦、疲倦乏力等。</td></tr><tr><td align="center">盐酸丙米嗪片(盐酸丙米嗪片)</td><td>用于各种抑郁症。因具有振奋作用，适用于迟钝型抑郁，但不宜用于激越型抑郁或焦虑性抑郁。亦可用于小儿遗尿症。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">舒必利片(舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr><tr><td align="center">盐酸氟西汀胶囊(盐酸氟西汀胶囊)</td><td>抑郁症：盐酸氟西汀胶囊用于治疗抑郁症状，伴有或不伴有焦虑症状，尤其是不需要镇静作用时。 强迫症。 神经性贪食症：盐酸氟西汀胶囊用于减少贪食和导泻行为。 惊恐障碍：盐酸氟西汀胶囊用于治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr><tr><td align="center">槟榔十三味丸(槟榔十三味丸)</td><td>调节“赫依”。安神止痛。用于心悸，失眠，精神失常，游走刺痛。病名注释：“游走刺痛”：本方指类似于胁间神经痛。 “赫依”本方指失眠健忘、神经衰弱、抑郁症、神经官能症、更年期综合症等。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多 发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛 以及疱疹后神经痛。预防或治疗躁狂-抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或与氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr><tr><td align="center">碳酸锂片(碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂-情感性精神病。</td></tr><tr><td align="center">奥氮平片(奥氮平片)</td><td>精神分裂症。双相情感障碍躁狂发作。双相情感障碍抑郁发作。奥氮平初始治疗有效的患者，可用于精神分裂症维持治疗和预防双相情感障碍复发。</td></tr><tr><td align="center">盐酸文拉法辛缓释胶囊(盐酸文拉法辛缓释胶囊)</td><td>本品适用于各种类型抑郁症，包括伴有焦虑的抑郁症，及广泛性焦虑症。1. 各种类型抑郁症本品推荐用于治疗各种类型抑郁症。 本品治疗符合诊断与统计手册第三版(修订版)(DSM-III-R)或诊断与统计手册第四版(DSM-IV)诊断标准的门诊成年抑郁症患者的疗效已在8周和12周的对照研究中得到确定。 一次抑郁发作(DSM-IV)是指明显和相对持久(在2周时间内的几乎每一天)的抑郁情绪伴有对几乎所有活动兴趣减退和愉快感的缺失，与其平时的表现明显不同，同时在2周的时间内具有以下9项症状中的5项：抑郁情绪、日常活动中的明显兴趣减退和愉快感缺失、体重和食欲的明显变化、失眠或睡眠过多、精神运动性激越或迟滞、疲劳、自责自罪或无价值感、思维迟缓和注意力难以集中以及自杀意念和自杀行为。 2. 广泛性焦虑症(GAD) 本品推荐用于治疗广泛性焦虑症患者。日常应激相关的焦虑和神经质一般不需要应用抗焦虑药。 在为期8周和6个月的安慰剂对照研究证实本品对符合DSM-IV诊断标准的GAD患者有效。 广泛性焦虑症(DSM-IV)是指维持至少6个月难以控制的过分焦虑和担心(预期)。 至少具有以下6项症状中的3项：坐立不安和神经质、容易疲劳、难以集中注意力或头脑空白、易怒、肌肉震颤和睡眠障碍。 尽管为期6个月的临床研究证实本品对广泛性焦虑症患者有效，但当医生选择本品作为长期治疗时应该定期评估药物对患者的长期疗效(见[用法用量])。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>1、癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。br&#x2F;&gt;br&#x2F;&gt;2、三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。br&#x2F;&gt;br&#x2F;&gt;3、预防或治疗躁狂-抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其他抗抑郁药合用。br&#x2F;&gt;br&#x2F;&gt;4、中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。br&#x2F;&gt;br&#x2F;&gt;5、酒精癖的戒断综合征。</td></tr><tr><td align="center">盐酸甲氯芬酯胶囊(盐酸甲氯芬酯胶囊)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr><tr><td align="center">盐酸甲氯芬酯胶囊(健瑙素)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr><tr><td align="center">碳酸锂片(碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂-情感性精神病。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂-抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr><tr><td align="center">槟榔十三味丸(槟榔十三味丸)</td><td>调节“赫依”。安神止痛。用于心悸，失眠，精神失常，游走刺痛。病名注释：“游走刺痛”：本方指类似于胁间神经痛。 “赫依”本方指失眠健忘、神经衰弱、抑郁症、神经官能症、更年期综合症等。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多 发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛 以及疱疹后神经痛。预防或治疗躁狂-抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或与氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr><tr><td align="center">碳酸锂片(碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂-情感性精神病。</td></tr><tr><td align="center">奥氮平片(奥氮平片)</td><td>精神分裂症。双相情感障碍躁狂发作。双相情感障碍抑郁发作。奥氮平初始治疗有效的患者，可用于精神分裂症维持治疗和预防双相情感障碍复发。</td></tr><tr><td align="center">盐酸文拉法辛缓释胶囊(盐酸文拉法辛缓释胶囊)</td><td>本品适用于各种类型抑郁症，包括伴有焦虑的抑郁症，及广泛性焦虑症。1. 各种类型抑郁症本品推荐用于治疗各种类型抑郁症。 本品治疗符合诊断与统计手册第三版(修订版)(DSM-III-R)或诊断与统计手册第四版(DSM-IV)诊断标准的门诊成年抑郁症患者的疗效已在8周和12周的对照研究中得到确定。 一次抑郁发作(DSM-IV)是指明显和相对持久(在2周时间内的几乎每一天)的抑郁情绪伴有对几乎所有活动兴趣减退和愉快感的缺失，与其平时的表现明显不同，同时在2周的时间内具有以下9项症状中的5项：抑郁情绪、日常活动中的明显兴趣减退和愉快感缺失、体重和食欲的明显变化、失眠或睡眠过多、精神运动性激越或迟滞、疲劳、自责自罪或无价值感、思维迟缓和注意力难以集中以及自杀意念和自杀行为。 2. 广泛性焦虑症(GAD) 本品推荐用于治疗广泛性焦虑症患者。日常应激相关的焦虑和神经质一般不需要应用抗焦虑药。 在为期8周和6个月的安慰剂对照研究证实本品对符合DSM-IV诊断标准的GAD患者有效。 广泛性焦虑症(DSM-IV)是指维持至少6个月难以控制的过分焦虑和担心(预期)。 至少具有以下6项症状中的3项：坐立不安和神经质、容易疲劳、难以集中注意力或头脑空白、易怒、肌肉震颤和睡眠障碍。 尽管为期6个月的临床研究证实本品对广泛性焦虑症患者有效，但当医生选择本品作为长期治疗时应该定期评估药物对患者的长期疗效(见[用法用量])。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>1、癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。br&#x2F;&gt;br&#x2F;&gt;2、三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。br&#x2F;&gt;br&#x2F;&gt;3、预防或治疗躁狂-抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其他抗抑郁药合用。br&#x2F;&gt;br&#x2F;&gt;4、中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。br&#x2F;&gt;br&#x2F;&gt;5、酒精癖的戒断综合征。</td></tr><tr><td align="center">盐酸甲氯芬酯胶囊(盐酸甲氯芬酯胶囊)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr><tr><td align="center">盐酸甲氯芬酯胶囊(健瑙素)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr><tr><td align="center">碳酸锂片(碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂-情感性精神病。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂-抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr><tr><td align="center">槟榔十三味丸(槟榔十三味丸)</td><td>调节“赫依”。安神止痛。用于心悸，失眠，精神失常，游走刺痛。病名注释：“游走刺痛”：本方指类似于胁间神经痛。 “赫依”本方指失眠健忘、神经衰弱、抑郁症、神经官能症、更年期综合症等。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多 发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛 以及疱疹后神经痛。预防或治疗躁狂-抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或与氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr><tr><td align="center">碳酸锂片(碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂-情感性精神病。</td></tr><tr><td align="center">奥氮平片(奥氮平片)</td><td>精神分裂症。双相情感障碍躁狂发作。双相情感障碍抑郁发作。奥氮平初始治疗有效的患者，可用于精神分裂症维持治疗和预防双相情感障碍复发。</td></tr><tr><td align="center">盐酸文拉法辛缓释胶囊(盐酸文拉法辛缓释胶囊)</td><td>本品适用于各种类型抑郁症，包括伴有焦虑的抑郁症，及广泛性焦虑症。1. 各种类型抑郁症本品推荐用于治疗各种类型抑郁症。 本品治疗符合诊断与统计手册第三版(修订版)(DSM-III-R)或诊断与统计手册第四版(DSM-IV)诊断标准的门诊成年抑郁症患者的疗效已在8周和12周的对照研究中得到确定。 一次抑郁发作(DSM-IV)是指明显和相对持久(在2周时间内的几乎每一天)的抑郁情绪伴有对几乎所有活动兴趣减退和愉快感的缺失，与其平时的表现明显不同，同时在2周的时间内具有以下9项症状中的5项：抑郁情绪、日常活动中的明显兴趣减退和愉快感缺失、体重和食欲的明显变化、失眠或睡眠过多、精神运动性激越或迟滞、疲劳、自责自罪或无价值感、思维迟缓和注意力难以集中以及自杀意念和自杀行为。 2. 广泛性焦虑症(GAD) 本品推荐用于治疗广泛性焦虑症患者。日常应激相关的焦虑和神经质一般不需要应用抗焦虑药。 在为期8周和6个月的安慰剂对照研究证实本品对符合DSM-IV诊断标准的GAD患者有效。 广泛性焦虑症(DSM-IV)是指维持至少6个月难以控制的过分焦虑和担心(预期)。 至少具有以下6项症状中的3项：坐立不安和神经质、容易疲劳、难以集中注意力或头脑空白、易怒、肌肉震颤和睡眠障碍。 尽管为期6个月的临床研究证实本品对广泛性焦虑症患者有效，但当医生选择本品作为长期治疗时应该定期评估药物对患者的长期疗效(见[用法用量])。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>1、癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。br&#x2F;&gt;br&#x2F;&gt;2、三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。br&#x2F;&gt;br&#x2F;&gt;3、预防或治疗躁狂-抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其他抗抑郁药合用。br&#x2F;&gt;br&#x2F;&gt;4、中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。br&#x2F;&gt;br&#x2F;&gt;5、酒精癖的戒断综合征。</td></tr><tr><td align="center">盐酸甲氯芬酯胶囊(盐酸甲氯芬酯胶囊)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr><tr><td align="center">盐酸甲氯芬酯胶囊(健瑙素)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr><tr><td align="center">碳酸锂片(碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂-情感性精神病。</td></tr><tr><td align="center">卡马西平片(卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂-抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂-抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Depression</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Depression</tag>
      
      <tag>Medicine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😃 树莓派折腾手册 (一)——准备系统 😃</title>
    <link href="/2021/06/18/rpi-1/"/>
    <url>/2021/06/18/rpi-1/</url>
    
    <content type="html"><![CDATA[<h1 id="😃-树莓派折腾手册-一-——准备系统-😃"><a href="#😃-树莓派折腾手册-一-——准备系统-😃" class="headerlink" title="😃 树莓派折腾手册 (一)——准备系统 😃"></a>😃 树莓派折腾手册 (一)——准备系统 😃</h1><h2 id="烧录官方Debian-10-buster系统镜像："><a href="#烧录官方Debian-10-buster系统镜像：" class="headerlink" title="烧录官方Debian 10 buster系统镜像："></a>烧录官方<code>Debian 10 buster</code>系统镜像：</h2><p> 先用 <strong>SDFormatter</strong> 格式化一下内存卡叭:</p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152409.png" alt="hZkDB8qxtRgQz3S"></p><h3 id="1-烧写镜像用到的软件：-Win32-Disk-Image"><a href="#1-烧写镜像用到的软件：-Win32-Disk-Image" class="headerlink" title="1. 烧写镜像用到的软件： Win32 Disk Image"></a>1. 烧写镜像用到的软件： <strong>Win32 Disk Image</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152403.png" alt="Zb6CEHnf17oqO5Q"></p><ul><li>然后在U盘的根目录建立一个空白的 <strong>ssh文件  方便ssh远程连接</strong><br><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/sasw.png" alt="FV5qpvWz7LtsOgi"></li><li>用 <strong>Windows PowerShell</strong> 连接树莓派ssh<br><code>shift+右键</code> 呼出<strong>Windows PowerShell</strong><br><strong>完整连接语法</strong>:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -p 端口号 用户名@主机地址<br></code></pre></td></tr></table></figure><blockquote><p>树莓派默认的用户名 <strong>pi</strong> 密码 <strong>raspberry</strong><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152448.png" alt="QLA74lscbwzRWY2"></p></blockquote><ul><li>树莓派扩展TF卡分区:<br>sudo raspi-config –&gt; Advanced options –&gt;Expand Filesystem, 确认重启</li></ul><h3 id="2-启动树莓派HDMI功能"><a href="#2-启动树莓派HDMI功能" class="headerlink" title="2. 启动树莓派HDMI功能 :"></a>2. 启动树莓派HDMI功能 :</h3><ul><li><p>编辑<code>config.txt</code>文件，修改以下参数:<br>sudo nano &#x2F;boot&#x2F;config.txt</p><ul><li>把下面#注释符号去掉<br>hdmi_force_hotplug&#x3D;1  #启用HDMI热插拔功能<br>config_hdmi_boost&#x3D;4    #启用加强HDMI信号</li></ul><blockquote><p>不出意外的话应该可以接上，但是我的没有声音输出诶<br>注：如果还是不能的话，找到#hdmi_group&#x3D;1这句话，把前面的#注释符号去掉，把数字改成 2强行指定显示器类型：1是连接老式电视，2代表连接新电视。</p></blockquote></li></ul><h2 id="树莓派-Debian-10-buster-换清华源："><a href="#树莓派-Debian-10-buster-换清华源：" class="headerlink" title="树莓派 Debian 10 buster 换清华源："></a>树莓派 <code>Debian 10 buster</code> 换清华源：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /etc/apt/sources.list<br>deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib<br>deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib<br><br>sudo nano /etc/apt/sources.list.d/raspi.list<br>deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui<br></code></pre></td></tr></table></figure><ul><li>更新源列表: <code>sudo apt-get update</code></li><li>更新软件版本，升级软件包: <code>sudo apt-get upgrade</code></li></ul><h2 id="树莓派rasp-config相关设置"><a href="#树莓派rasp-config相关设置" class="headerlink" title="树莓派rasp-config相关设置"></a>树莓派<code>rasp-config</code>相关设置</h2><h3 id="1-设置pi，root用户密码，并解锁"><a href="#1-设置pi，root用户密码，并解锁" class="headerlink" title="1. 设置pi，root用户密码，并解锁:"></a>1. 设置pi，root用户密码，并解锁:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">树莓派修改密码，顺便解锁root用户</span><br>sudo passwd pi<br>sudo passwd root<br><span class="hljs-meta prompt_">#</span><span class="language-bash">解锁root用户</span><br>sudo passwd --unlock root<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果想在终端直接用root用户登录，编辑</span><br>sudo nano /etc/ssh/sshd_config<br>修改 PermitRootLogin without-password 为 PermitRootLogin yes<br></code></pre></td></tr></table></figure><h3 id="2-respi本地化操作"><a href="#2-respi本地化操作" class="headerlink" title="2. respi本地化操作 :"></a>2. <strong>respi本地化</strong>操作 :</h3><ul><li>安装中文字体，提供几个Linux中文字体库:</li></ul> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install xfonts-wqy<br>sudo apt-get install ttf-wqy-zenhei ttf-wqy-microhei<br></code></pre></td></tr></table></figure><ul><li>设置终端中文显示: <code>sudo raspi-config</code>:<br>选择change_locale，在Default locale for the system environment:中选择zh_CN.UTF-8。<br>往下翻一会儿直到找到zh_CN UTF-8把光标移动到前面，然后按下空格键打上*<br><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152513.png" alt="3hQeD8k9L1mgTZc"></li><li>改变键盘布局: <code>sudo dpkg-reconfigure keyboard-configuration</code></li></ul><h3 id="3-设置-vnc桌面-连接"><a href="#3-设置-vnc桌面-连接" class="headerlink" title="3. 设置 vnc桌面 连接"></a>3. 设置 vnc桌面 连接</h3><blockquote><p>注:这里放弃了树莓派自带的 <strong>realvnc</strong> 因为不支持网页 <strong>novnc</strong> 且功能很少，所以用 <strong>Tightvnc</strong> 代替</p></blockquote><ul><li>安装<strong>Tightvncserver</strong>: <code>sudo apt-get install tightvncserver</code></li><li>安装好之后设置一个<strong>VNC密码</strong>:  vncpasswd</li></ul><blockquote><p>注: 先输入操作密码两次，然后会询问是否设置一个查看(view-only)密码，按自己喜欢，一般没必要。</p></blockquote><ul><li>设置<strong>开机自启动</strong> :</li></ul><blockquote><p>设置<strong>开机启动</strong>，需要在 <strong>&#x2F;etc&#x2F;init.d&#x2F;</strong> 中创建一个文件。例如<strong>tightvncserver</strong>:  (启动脚本的名称，有和程序名一致的习惯)</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo nano /etc/init.d/tightvncserver<br><span class="hljs-comment"># 内容如下:</span><br><span class="hljs-comment">#!/bin/sh</span><br><span class="hljs-comment">### BEGIN INIT INFO</span><br><span class="hljs-comment"># Provides:          tightvncserver</span><br><span class="hljs-comment"># Required-Start:    $local_fs</span><br><span class="hljs-comment"># Required-Stop:     $local_fs</span><br><span class="hljs-comment"># Default-Start:     2 3 4 5</span><br><span class="hljs-comment"># Default-Stop:      0 1 6</span><br><span class="hljs-comment"># Short-Description: Start/stop tightvncserver</span><br><span class="hljs-comment">### END INIT INFO</span><br><br><span class="hljs-comment"># More details see:</span><br><span class="hljs-comment"># http://www.penguintutor.com/linux/tightvnc</span><br><br><span class="hljs-comment">### Customize this entry</span><br><span class="hljs-comment"># Set the USER variable to the name of the user to start tightvncserver under</span><br><span class="hljs-built_in">export</span> USER=<span class="hljs-string">&#x27;pi&#x27;</span><br><span class="hljs-comment">### End customization required</span><br><br><span class="hljs-built_in">eval</span> <span class="hljs-built_in">cd</span> ~<span class="hljs-variable">$USER</span><br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span><br>  start)<br>    <span class="hljs-comment"># 启动命令行。此处自定义分辨率、控制台号码或其它参数。</span><br>    su <span class="hljs-variable">$USER</span> -c <span class="hljs-string">&#x27;/usr/bin/tightvncserver -depth 16 -geometry 800x600 :1&#x27;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting TightVNC server for <span class="hljs-variable">$USER</span> &quot;</span><br>    ;;<br>  stop)<br>    <span class="hljs-comment"># 终止命令行。此处控制台号码与启动一致。</span><br>    su <span class="hljs-variable">$USER</span> -c <span class="hljs-string">&#x27;/usr/bin/tightvncserver -kill :1&#x27;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Tightvncserver stopped&quot;</span><br>    ;;<br>  *)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: /etc/init.d/tightvncserver &#123;start|stop&#125;&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br>    ;;<br><span class="hljs-keyword">esac</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure><p>然后给<strong>tightvncserver文件</strong>加<strong>执行权限</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod 755 /etc/init.d/tightvncserver<br></code></pre></td></tr></table></figure><p>并更新<strong>开机启动列表</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-rc.d tightvncserver defaults<br></code></pre></td></tr></table></figure><p>一些<strong>service命令</strong> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service tightvncserver restart #重启服务<br>sudo service tightvncserver start/stop #关闭/开启服务<br>sudo service tightvncserver status #查看服务运行状态<br></code></pre></td></tr></table></figure><blockquote><p>附:   vnc客户端下载<br><a href="https://www.realvnc.com/en/connect/download/viewer/">vnc官网</a></p></blockquote><p>连接成功惹~:<br><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152521.png"><br><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152531.png"><br>编辑 .&#x2F;vnc&#x2F;xstartup 配置文件使其能与windown共享剪贴板</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano .vnc/xstartup<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">在后方追加</span><br>vncconfig -nowin -iconic &amp;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重启Tightvncserver</span><br>sudo service tightvncserver restart<br></code></pre></td></tr></table></figure><h3 id="4-部署novnc网页"><a href="#4-部署novnc网页" class="headerlink" title="4.部署novnc网页 :"></a>4.部署<strong>novnc网页</strong> :</h3><blockquote><p>方便在网页上控制树莓派屏幕，但是<strong>不支持realvnc</strong></p></blockquote><ul><li>安装 <strong>git 支持</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install git<br></code></pre></td></tr></table></figure><ul><li><strong>克隆</strong> novnc项目:</li></ul><blockquote><p>在中国大陆听说<del>加上 <em><a href="https://gproxy.cn/">https://gproxy.cn</a></em> 就可以加速 <strong>克隆</strong> 速度丫</del> 改口 应换成  <a href="https://github.com.cnpmjs.org/">https://github.com.cnpmjs.org/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/kanaka/noVNC #源地址<br>git clone https://github.com.cnpmjs.org/kanaka/noVNC #加速地址<br></code></pre></td></tr></table></figure><ul><li>运行 <strong>novnc</strong> 并设置<strong>开机自启动</strong>:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd noVNC<br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化可能有点点慢</span><br>./utils/launch.sh --vnc localhost:5901 #监听5901 vnc端口<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152538.png"></p><ul><li>尝试访问: <a href="http://raspiberry:6080/">http://raspiberry:6080</a>  可<br><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152542.png"></li><li>一些<strong>高级设置</strong> :</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./utils/websockify --web ./ 8787 localhost:5901  #修改6080默认端口<br>./utils/websockify --web ./ 8787 192.168.1.10:5901 #可以讲localhost改成所有安装了vncserver的IP地址<br></code></pre></td></tr></table></figure><p> <strong>连接速度太慢可以安装Python的numpy库解决</strong></p><ul><li>设置<strong>开机启动</strong>：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">编辑开机启动项</span><br>sudo nano /etc/rc.local<br><span class="hljs-meta prompt_">#</span><span class="language-bash">以pi用户运行程序</span><br>su pi -c &quot;/home/pi/noVNC/utils/launch.sh --vnc localhost:5901&quot; &amp;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152617.png" alt="fEVci5dlNCMaUs4"></p><h3 id="5-安装cockpit-web可视化管理"><a href="#5-安装cockpit-web可视化管理" class="headerlink" title="5.安装cockpit web可视化管理"></a>5.安装<code>cockpit</code> web可视化管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install cockpit<br></code></pre></td></tr></table></figure><blockquote><p>安装的依赖有  <strong>一丢丢多</strong></p></blockquote><ul><li>默认是用<code>https</code>访问，需要修改配置文件使其能<code>http</code>访问</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /etc/cockpit/cockpit.conf #这个文件默认是不存在的需要新建<br><br>[WebService]<br>AllowUnencrypted=true<br>LoginTitle=鲸云pi<br></code></pre></td></tr></table></figure><ul><li>配置<strong>开机启动</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable cockpit.socket<br>sudo systemctl start cockpit.socket<br></code></pre></td></tr></table></figure><ul><li><p>页面</p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152626.png" alt="image-20200805174634421"></p></li></ul><h2 id="Python设置"><a href="#Python设置" class="headerlink" title="Python设置"></a>Python设置</h2><h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><blockquote><p>树莓派默认安装了两个版本的<strong>Python</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152632.png"></p><h3 id="树莓派pip换源"><a href="#树莓派pip换源" class="headerlink" title="树莓派pip换源"></a>树莓派pip换源</h3><blockquote><p><strong>pip</strong>更换为<strong>国内源</strong>，可以大大的提高安装成功率和速度。不管你用的是<strong>pip3还是pip，方法都是一样的</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/.pip<br>nano ~/.pip/pip.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">写入</span><br>[global]<br>timeout = 5000<br>index-url = https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple<br>[install]<br>use-mirrors = true<br>mirrors = https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple<br></code></pre></td></tr></table></figure><ul><li><strong>更新pip版本</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 -m pip install --upgrade pip<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152649.png" alt="seVOiSZrBKgE827"></p><ul><li><strong>树莓派指定Python版本安装模块</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pip3 install XXX   #Python3版本<br>sudo pip install XXX   #Python2版本<br></code></pre></td></tr></table></figure><h2 id="部署zsh"><a href="#部署zsh" class="headerlink" title="部署zsh"></a>部署zsh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh -c &quot;$(wget -O- https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)&quot;<br><br>git clone https://github.com.cnpmjs.org/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions<br><br> git clone https://github.com.cnpmjs.org/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting<br> <br> ZSH_DISABLE_COMPFIX=true<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Respi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😏 树莓派折腾手册（三）——搭建离线下载器 👀</title>
    <link href="/2021/06/18/rpi-2/"/>
    <url>/2021/06/18/rpi-2/</url>
    
    <content type="html"><![CDATA[<h1 id="😏-树莓派折腾手册（三）——搭建离线下载器-👀"><a href="#😏-树莓派折腾手册（三）——搭建离线下载器-👀" class="headerlink" title="😏 树莓派折腾手册（三）——搭建离线下载器 👀"></a>😏 树莓派折腾手册（三）——搭建离线下载器 👀</h1><h2 id="1-挂载硬盘-x2F-U盘"><a href="#1-挂载硬盘-x2F-U盘" class="headerlink" title="1.挂载硬盘&#x2F;U盘"></a>1.挂载硬盘&#x2F;U盘</h2><blockquote><p><strong>注意：开始之前先把存储设备格式化成</strong> <strong>fat32文件系统</strong> </p></blockquote><ul><li><p>树莓派4B Debian10系统插上储存设备后默认自动挂载到  <code>/media</code> 目录我们先卸载U盘：</p><p>查询硬盘状态:   <code>sudo fdisk -l</code> </p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619153119.png" alt="9XBTemAzD6R8yot"></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo umount /media/pi/PI   #这里不能照抄命令，要根据实际情况更改 <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果出现 target is busy 的情况，我们要强行结束U盘目录下的进程</span> <br>sudo fuser -mv -k /media/U盘 名字    # 然后再执行umount卸载命令 <br></code></pre></td></tr></table></figure><ul><li>编辑<code>/etc/fstab</code>中添加像下面这样的挂载配置：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>fstab<br><br><span class="hljs-regexp">/dev/</span>sda1 <span class="hljs-regexp">/home/</span>pi/disk vfat utf8,uid=<span class="hljs-number">1000</span>,gid=<span class="hljs-number">1000</span>,umask=<span class="hljs-number">000</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-comment">#挂载点需要自行更改 sda1要加数字</span><br><br>sudo reboot<br><br>mount <span class="hljs-regexp">/dev/</span>sda1 <span class="hljs-regexp">/home/</span>pi/disk -o utf8,uid=<span class="hljs-number">1000</span>,gid=<span class="hljs-number">1000</span>,umask=<span class="hljs-number">000</span> -t vfat<br></code></pre></td></tr></table></figure><ul><li><p>重启 ，不出意外的话开机 应该 会自动挂载，且有写权限，用户是pi：如图挂载至 <code>/home/pi/disk</code> 目录，有<strong>777权限</strong></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619153142.png" alt="3ilg9S1UJ2EcHPV"></p></li></ul><h2 id="2-部署Aria2离线下载器"><a href="#2-部署Aria2离线下载器" class="headerlink" title="2.部署Aria2离线下载器"></a>2.部署Aria2离线下载器</h2><ul><li>下载安装<code>Aria2</code>:</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update<br>sudo apt-<span class="hljs-built_in">get</span> install aria2<br></code></pre></td></tr></table></figure><ul><li><p>安装nginx：</p><blockquote><p>上面已经安装过的<strong>小可爱</strong>可以<strong>跳过</strong></p></blockquote></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install nginx<br></code></pre></td></tr></table></figure><ul><li><p>配置Aria2， 创建配置文件： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建目录 </span><br>sudo <span class="hljs-built_in">mkdir</span> /etc/aria2/ <br><span class="hljs-comment">#创建配置文件 </span><br>sudo <span class="hljs-built_in">touch</span> /etc/aria2/aria2.conf <br><span class="hljs-comment">#创建aria2用户 </span><br>sudo useradd -M -s /usr/sbin/nologin aria2 <br><span class="hljs-comment">#创建session文件，用于保存进度: </span><br>sudo <span class="hljs-built_in">touch</span> /etc/aria2/aria2.session <br><span class="hljs-comment">#修改文件拥有者为aria2： </span><br>sudo <span class="hljs-built_in">chown</span> aria2 /etc/aria2 /etc/aria2/aria2.session<br></code></pre></td></tr></table></figure></li><li><p>编辑<code>Aria2配置</code>文件:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#根据需要编辑文件: </span><br>sudo nano /etc/aria2/aria2.conf <br><span class="hljs-comment">#配置实例</span><br><br><span class="hljs-comment">#默认下载位置，需要改这里！！ </span><br><span class="hljs-attribute">dir</span>=/home/pi/disk <br><span class="hljs-comment">#断点续传 </span><br><span class="hljs-attribute">continue</span>=<span class="hljs-literal">true</span> <br><span class="hljs-attribute">min-split-size</span>=10M <br><span class="hljs-attribute">input-file</span>=/etc/aria2/aria2.session <br><span class="hljs-attribute">save-session</span>=/etc/aria2/aria2.session <br><span class="hljs-attribute">enable-rpc</span>=<span class="hljs-literal">true</span> <br><span class="hljs-attribute">rpc-allow-origin-all</span>=<span class="hljs-literal">true</span> <br><span class="hljs-comment">#只让本机访问6800端口，因为下面让nginx代理 </span><br><span class="hljs-attribute">rpc-listen-all</span>=<span class="hljs-literal">false</span> <br><span class="hljs-comment">#rpc秘钥，需要改这里 </span><br><span class="hljs-attribute">rpc-secret</span>=123456 <br>rpc默认端口为6800<br><span class="hljs-comment">#rpc-listen-port=6800 </span><br><span class="hljs-attribute">listen-port</span>=51413  <br><span class="hljs-attribute">enable-dht</span>=<span class="hljs-literal">false</span> <br><span class="hljs-attribute">enable-peer-exchange</span>=<span class="hljs-literal">false</span> <br><span class="hljs-attribute">peer-id-prefix</span>=-TR2770- <br><span class="hljs-attribute">user-agent</span>=Transmission/2.77 <br><span class="hljs-attribute">seed-ratio</span>=0 <br><span class="hljs-attribute">bt-seed-unverified</span>=<span class="hljs-literal">true</span> <br><span class="hljs-attribute">bt-save-metadata</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>创建<strong>systemd</strong>文件在 <code>/lib/systemd/system/aria2.service</code> 为如下: </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo nano /lib/systemd/system/aria2.service<br><br><span class="hljs-comment">#配置实例 </span><br>[Unit] <br><span class="hljs-attribute">Description</span>=Aria2c download manager <br><span class="hljs-attribute">After</span>=network.target  <br>[Service] <br><span class="hljs-attribute">Type</span>=simple <br><span class="hljs-attribute">User</span>=aria2 <br><span class="hljs-attribute">ExecStart</span>=/usr/bin/aria2c  <span class="hljs-attribute">--conf-path</span>=/etc/aria2/aria2.conf  [Install] <br><span class="hljs-attribute">WantedBy</span>=multi-user.target <br></code></pre></td></tr></table></figure></li><li><p>启动<strong>Aria2</strong>:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#启动Aria2 </span><br>sudo systemctl start aria2.service <br><span class="hljs-comment">#可以设置开机启动 </span><br>sudo systemctl <span class="hljs-built_in">enable</span> aria2.service <br><span class="hljs-comment">#如果要关闭开机启动 </span><br>sudo systemctl <span class="hljs-built_in">disable</span> aria2.service<br></code></pre></td></tr></table></figure></li><li><p>配置<strong>nginx+ariaNg</strong>可视化管理页面：</p><blockquote><p>到<a href="https://github.com/mayswind/AriaNg/releases"><strong>AriaNG</strong>开源项目页面</a> 获取最新版版本</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619153158.png" alt="UO7c5EItjBHRsgN"></p><p><strong>把源码克隆到</strong> <code>/website/AriaNg/</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir /website<br>sudo chmod 777 -R /website<br>cd /website<br>mkdir AriaNg<br>cd AriaNg<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">自己复制最新版链接</span><br>wget https://github.com/mayswind/AriaNg/releases/download/1.1.6/AriaNg-1.1.6.zip<br><span class="hljs-meta prompt_">#</span><span class="language-bash">祖国加速通道</span><br>wget https://gproxy.cn/https://github.com/mayswind/AriaNg/releases/download/1.1.6/AriaNg-1.1.6.zip<br><span class="hljs-meta prompt_">#</span><span class="language-bash">解压</span><br>unzip AriaNg-1.1.6.zip<br>rm AriaNg-1.1.6.zip<br><span class="hljs-meta prompt_">#</span><span class="language-bash">授权</span><br>sudo chmod 777 -R /website<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>为了方便使用，我把<strong>AriaNg</strong>和<strong>jsonrpc</strong>都配置在了 <strong>80 端口</strong>，利用nginx的<strong>代理功能</strong>，把本机 6800 端口隐藏,对外<strong>只暴露 80 端口.</strong> </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">修改nginx配置文件</span> <br>sudo nano /etc/nginx/sites-enabled/default<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加配置aria2Ng</span> <br>location /aria2 &#123; <br>            alias /website/AriaNg/; <br>            index index.html; <br>    &#125; <br><span class="hljs-meta prompt_">#</span><span class="language-bash">代理jsonrpc</span> <br>location /jsonrpc &#123; <br>       proxy_pass http://localhost:6800/jsonrpc; <br>            proxy_redirect off; <br>            proxy_set_header        X-Real-IP       $remote_addr; <br>            proxy_set_header        X-Forwarded-For     $proxy_add_x_forwarded_for; <br>            proxy_set_header Host $host; <br>            #以下代码使支持WebSocket <br>            proxy_http_version 1.1; <br>            proxy_set_header Upgrade $http_upgrade; <br>            proxy_set_header Connection &quot;upgrade&quot;; <br>&#125; <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">最后别忘记重启nginx</span> <br>sudo systemctl restart nginx <br></code></pre></td></tr></table></figure><ul><li><p>尝试访问 <a href="http://树莓派ip/aria2">http:&#x2F;&#x2F;树莓派ip&#x2F;aria2</a> ，<strong>设置参数</strong></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619153219.png" alt="wNbqhBl7KWL6Jcx"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619153228.png" alt="2o7a8c3qpFODP4Y"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Respi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😜 树莓派折腾手册 (二)——手动搭建LNMP网站服务器环境 🙏</title>
    <link href="/2021/06/18/rpi-3/"/>
    <url>/2021/06/18/rpi-3/</url>
    
    <content type="html"><![CDATA[<h1 id="😜-树莓派折腾手册-二-——手动搭建LNMP网站服务器环境-🙏"><a href="#😜-树莓派折腾手册-二-——手动搭建LNMP网站服务器环境-🙏" class="headerlink" title="😜 树莓派折腾手册 (二)——手动搭建LNMP网站服务器环境 🙏"></a>😜 树莓派折腾手册 (二)——手动搭建LNMP网站服务器环境 🙏</h1><blockquote><p>前言：这个东西我折腾了很久，试过一键部署脚本: <a href="https://lnmp.org/auto.html">https://lnmp.org/auto</a>但是我想在局域网+frp穿透的外网，访问树莓派的网站，但是只能绑定一个域名，反正用多了就出各种问题，可能我不会用 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update   #好习惯，安装软件前先更新源列表 <br></code></pre></td></tr></table></figure><h2 id="1-安装PHP7-3"><a href="#1-安装PHP7-3" class="headerlink" title="1.安装PHP7.3"></a><strong>1.安装PHP7.3</strong></h2><blockquote><p><strong>这里跳了很多坑，后来查文档才发现Debian 10 buster只能安装PHP7.0以上的版本</strong> </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install -y -t buster php7.3-fpm php7.3-curl php7.3-gd php7.3-intl php7.3-mbstring php7.3-mysql php7.3-imap php7.3-opcache php7.3-sqlite3 php7.3-xml php7.3-xmlrpc php7.3-zip <br></code></pre></td></tr></table></figure><p>通过命令<code>php -v</code>能够看到PHP版本号7.3，说明安装完成:</p><blockquote><p>输出显示配置文件在&#x2F;etc&#x2F;php&#x2F;7.3&#x2F;cli&#x2F;php.ini。注意，实际上配置文件有两个，另外一个在&#x2F;etc&#x2F;php&#x2F;7.3&#x2F;fpm&#x2F;php.ini。通过命令行调用php时，会使用第一个配置文件；通过fpm调用php（例如nginx）会使用第二个配置文件。  </p></blockquote><p>php-fpm常用管理命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">开启php-fpm:<br>sudo systemctl start php7.3-fpm <br>关闭php-fpm: <br>sudo systemctl stop php7.3-fpm <br>重启php-fpm: <br>sudo systemctl restart php7.3-fpm <br>编辑php-fpm配置文件:<br>sudo nano /etc/php/7.3/fpm/php.ini <br></code></pre></td></tr></table></figure><h2 id="2-安装nginx"><a href="#2-安装nginx" class="headerlink" title="2.安装nginx:"></a><strong>2.安装nginx:</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install nginx<br></code></pre></td></tr></table></figure><blockquote><p>安装完成后，会自动开启nginx。在浏览器输入树莓派的IP地址，可以看到“Welcome to nginx!”</p></blockquote><p><strong>nginx常用管理命令：</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">启动nginx: sudo systemctl start nginx <br>关闭nginx：sudo systemctl stop nginx <br>设置nginx开机启动：sudo systemctl enable nginx <br>重启nginx：sudo systemctl restart nginx <br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置文件的位置：</span> <br>默认的网站根目录：/var/www/html <br>nginx配置文件目录：/etc/nginx/ <br>nginx主配置文件位置：/etc/nginx/nginx.conf <br></code></pre></td></tr></table></figure><h2 id="3-配置nginx解析php-关键"><a href="#3-配置nginx解析php-关键" class="headerlink" title="3.配置nginx解析php (关键)"></a>3.配置nginx解析php (关键)</h2><ul><li>编辑配置nginx文件:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /etc/nginx/sites-enabled/default <br></code></pre></td></tr></table></figure><p>找到<code># pass PHP scripts to FastCGI server</code>后面的 <code>location</code> ，删除注释。修改后如下： </p><blockquote><p>PHP的默认路径转发有问题导致的,因为很多nginx的默认PHP配置文件的写法为 <strong>location ~ .php</strong> 要改成 *<em>location~.<em>.php(/.</em>)</em>$** </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">index index.php index.html index.htm index.nginx-debian.html; <br>location ~ .*\.php(\/.*)*$ &#123; <br>include snippets/fastcgi-php.conf; <br><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment">## With php-fpm (or other unix sockets):</span></span> <br>    fastcgi_pass unix:/run/php/php7.3-fpm.sock; <br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># With php-cgi (or other tcp sockets):</span></span> <br><span class="hljs-meta prompt_">#</span><span class="language-bash">fastcgi_pass 127.0.0.1:9000;</span> <br>&#125; <br></code></pre></td></tr></table></figure><ul><li>保存后重启nginx：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl restart nginx<br></code></pre></td></tr></table></figure><p><strong>重启无报错则修改成功啦:</strong><br><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152804.png"></p><ul><li>在网站根目录创建一个php文件：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /var/www/html/index.php <br></code></pre></td></tr></table></figure><p>写入以下php代码并保存： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;?php phpinfo(); <br></code></pre></td></tr></table></figure><p>在浏览器中输入树莓派的IP地址即可看到phpinfo:<br><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152811.png"></p><h2 id="4-安装mariaDB数据库"><a href="#4-安装mariaDB数据库" class="headerlink" title="4.安装mariaDB数据库"></a><strong>4.安装mariaDB数据库</strong></h2><ul><li>使用以下命令安装<code>mariadb</code>:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install mariadb-server mariadb-client <br></code></pre></td></tr></table></figure><ul><li>执行数据库初始化安装:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mysql_secure_installation <br></code></pre></td></tr></table></figure><blockquote><p>根据提示设置数据库<code>root用户密码</code>、<code>是否允许外网访问</code>等，建议用<strong>翻译软件</strong>，一步步翻译。  <code>回车 n Y n Y Y</code>   </p></blockquote><ul><li>尝试用<strong>普通用户pi</strong>登录数据库:<br><code>mysql -u root -p</code><br>输入上一步设置的密码，发现无法登录，错误提示如下:</li></ul><blockquote><p>ERROR 1698 (28000): Access denied for user ‘root’@’localhost’</p></blockquote><p>原因: 数据库默认使用<strong>特权用户root登录</strong>，需要修改为<strong>普通用户使用密码登录</strong><br>-尝试用<strong>特权用户root</strong>登录数据库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mysql -u root# 登入数据库后，依次执行以下SQL： use mysql;update user set plugin=&#x27;mysql_native_password&#x27;;flush privileges;exit;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152818.png"></p><p>再次使用普通用户pi <code>mysql -u root -p</code> 即可通过密码登录数据库，无需root权限执行:</p><p> <img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152823.png"></p><ul><li>设置<strong>数据库密码</strong><br><strong>依次执行以下SQL：</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">use mysql;   <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> password<span class="hljs-operator">=</span>password(<span class="hljs-string">&#x27;123456&#x27;</span>) <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;root&#x27;</span>;   flush privileges;   exit; <br></code></pre></td></tr></table></figure><ul><li>设置<strong>mariaDB数据库</strong> <em><strong>外部网络访问权限</strong></em></li></ul><blockquote><p>根据官方的说法， MariaDB为了<strong>提高安全性</strong>，默认只监听127.0.0.1中的3306端口并且禁止了远程的TCP链接，我们可以通过下面两步来开启<strong>MySQL的远程服务</strong></p></blockquote><ol><li>打开文件<code>sudo nano /etc/mysql/mariadb.conf.d/50-server.cnf</code>，注释掉bind-address项，如下:<br><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152829.png"></li><li>开启了<strong>MySQL监听远程连接</strong>的选项，接下来需要给对应的<strong>MySQL账户分配权限</strong>，允许使用该账户<strong>远程连接</strong>到MySQL:<br>查看<strong>用户账号信息</strong>：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">User</span>,host <span class="hljs-keyword">from</span> mysql.user;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152834.png"><br><strong>root账户</strong>中的host项是<strong>localhost</strong>表示该账号只能进行<strong>本地登录</strong>，我们需要<strong>修改权限</strong>，执行MySQL命令:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;FLUSH PRIVILEGES;exit;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152851.png"></p><blockquote><p>这个时候发现相比之前<strong>多了一项</strong>，它的<strong>host项是%<strong>，这个时候说明配置成功了，我们可以用该账号进行</strong>远程访问</strong>了</p></blockquote><ul><li><strong>mariadb配置文件</strong>保存在多个位置:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/etc/mysql/mariadb.cnf /etc/mysql/mariadb.conf.d/ /etc/mysql/conf.d/ <br></code></pre></td></tr></table></figure><ul><li><strong>mariadb常用</strong>命令:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">启动mariadb: sudo systemctl start mariadb <span class="hljs-comment">#关闭/开启/重启 mariadb：systemctl stop/start/restart mariadb #设置mariadb开机启动：sudo systemctl enable mariadb</span></span> <br></code></pre></td></tr></table></figure><ul><li><strong>连接MySQL</strong>数据库命令:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -h主机地址 -u用户名 －p用户密码<br></code></pre></td></tr></table></figure><blockquote><p><strong>(注:u与root可以不用加空格，其它也一样)</strong></p></blockquote><h2 id="5-安装phpmyadmin可视化MySQL管理工具"><a href="#5-安装phpmyadmin可视化MySQL管理工具" class="headerlink" title="5.安装phpmyadmin可视化MySQL管理工具"></a>5.安装<code>phpmyadmin</code>可视化MySQL管理工具</h2><blockquote><p><strong>官方网站</strong>:  <a href="https://www.phpmyadmin.net/">phpmyadmin官网</a></p><ul><li>用<strong>wget</strong>下载源码包包到web目录<br>(请自行到官网获取最新下载链接)，截至2020&#x2F;8&#x2F;4版本为:<br><strong>phpMyAdmin-5.0.2-all-languages.zip</strong></li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://gproxy.cn/https://github.com/phpmyadmin/phpmyadmin/archive/RELEASE_5_0_4.zip<br></code></pre></td></tr></table></figure><ul><li><strong>解压zip格式</strong>源码包包到<strong>web目录</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod 777 -R /var/www/html/unzip -d /var/www/html/ ~/phpMyAdmin-5.0.2-all-languages.zip <br></code></pre></td></tr></table></figure><blockquote><p>若unzip不受支持请安装<br><strong>sudo apt-get install unzip</strong></p></blockquote><ul><li><strong>重命名文件夹并修改参数</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /var/www/html/mv phpMyAdmin-5.0.2-all-languages phpmyadmincd phpmyadminmv config.sample.inc.php config.inc.phpnano config.inc.php$cfg[&#x27;AllowArbitraryServer&#x27;] = true;<br></code></pre></td></tr></table></figure><p>编辑<code>config.inc.php</code>文件，修改密钥字段:<br><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152859.png"></p><blockquote><p>修改<strong>blowfish_secret</strong>字段，后面的密钥无仅仅用于加密而已，<strong>尽量足够长</strong>。<strong>当然偷偷插入<del>喜欢的女孩子</del>名字也是可以的哦</strong></p></blockquote><ul><li>把<strong>config.inc.php文件权限修改</strong>为744</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod 744 config.inc.php<br></code></pre></td></tr></table></figure><ul><li>尝试访问 http:&#x2F;&#x2F;你的树莓派ip&#x2F;phpmyadmin<br><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152752.png"><br><strong>启动高级功能</strong> 会新建一个phpmyadmin数据库<br><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152912.png"><br><strong>安装成功！</strong><br><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152920.png"></li></ul><h2 id="6-搭建多个nginx虚拟主机"><a href="#6-搭建多个nginx虚拟主机" class="headerlink" title="6.搭建多个nginx虚拟主机"></a>6.搭建多个<code>nginx</code>虚拟主机</h2><blockquote><p>有时候我们要在主机的<strong>不同端口</strong>搭建不同用处的<strong>web服务</strong>，这时就需要多个新建多个nginx虚拟主机的啦~</p></blockquote><ul><li><p>打开<code>nginx</code>主配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152925.png" alt="image-20200805160257592"></p></li></ul><p>找到<code>include</code>字段就是每个<strong>虚拟主机配置文件</strong>，为了方便管理，我们在<strong>用户家目录</strong>新建一个<code>nginx-conf</code>存放我们的<strong>nginx虚拟主机文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在配置文件插入include /home/pi/nginx-conf/*;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152933.png" alt="image-20200805160615360"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /home/pi/nginx-confnano /home/pi/nginx-conf/kodbox.conf<br></code></pre></td></tr></table></figure><p>写入以下内容:           <em><strong>(贴出一份完整的nginx虚拟主机配置，需要自行修改两个参数)</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">监听端口 两个都要改server &#123;listen 88 default_server;listen [::]:88 default_server;<span class="hljs-comment"># SSL configuration## listen 443 ssl default_server;# listen [::]:443 ssl default_server;## include snippets/snakeoil.conf;root /home/pi/kodbox; #网站根目录位置# Add index.php to the list if you are using PHPindex index.php index.html index.htm index.nginx-debian.html;server_name _;location / &#123;try_files $uri $uri/ =404;&#125;# pass PHP scripts to FastCGI server#location ~ .*\.php(\/.*)*$ &#123;include snippets/fastcgi-php.conf;fastcgi_pass unix:/run/php/php7.3-fpm.sock;&#125;&#125;</span></span><br></code></pre></td></tr></table></figure><p>重启<code>nginx</code>，愿一切安好:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl restart nginxwget --content-disposition https://packagecloud.io/headmelted/codebuilds/packages/debian/stretch/code-oss_1.45.0-1586135971_arm64.deb/download.deb<br></code></pre></td></tr></table></figure><h2 id="7-树莓派PHP调优"><a href="#7-树莓派PHP调优" class="headerlink" title="7. 树莓派PHP调优"></a>7. 树莓派<code>PHP</code>调优</h2><blockquote><h4 id="lnmp默认环境部署完成后，进行调优以应对多并发，复杂任务的情景"><a href="#lnmp默认环境部署完成后，进行调优以应对多并发，复杂任务的情景" class="headerlink" title="lnmp默认环境部署完成后，进行调优以应对多并发，复杂任务的情景"></a><strong>lnmp默认环境</strong>部署完成后，进行调优以应对<strong>多并发，复杂任务的情景</strong></h4></blockquote><ul><li><p>部署<strong>PHP探针</strong>以测试</p><blockquote><p>部署服务器探针推荐X探针，GitHub项目地址：</p><p><a href="https://github.com/kmvan/x-prober">GitHub X刘海探针</a></p></blockquote></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">克隆项目到www目录<span class="hljs-built_in">cd</span> /var/www/htmlwget https://github.com/kmvan/x-prober/raw/master/dist/prober.php<span class="hljs-comment">#删除默认页rm index.phpmv prober.php index.phpsudo chmod 777 index.php</span></span><br></code></pre></td></tr></table></figure><p><strong>尝试</strong>访问 <code>http://树莓派ip</code> :</p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152940.png" alt="image-20200807132503823"></p><blockquote><p>可以看到这些参数都是好   <strong>鸡肋的</strong></p></blockquote><ul><li>修改<strong>php.ini</strong> 仔细看好喽~</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /etc/php/7.3/fpm/php.ini<br></code></pre></td></tr></table></figure><p>修改 <em><strong>post 方式提交的数据大小</strong></em>，查找：<code>post_max_size</code> <strong>酌情修改为2000M</strong></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152945.png" alt="image-20200807133234597"></p><p>修改 <em><strong>运行超时秒数</strong></em> ，查找：<code>max_execution_time</code> <strong>酌情修改为3600s</strong></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152950.png" alt="image-20200807133453326"></p><p>修改 <em><strong>上传文件限制</strong></em> ，查找：<code>upload_max_filesize</code> <strong>酌情修改为2000M</strong></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619152956.png" alt="image-20200807133741086"></p><p>修改 <em><strong>运行内存限制</strong></em> ，查找：<code>memory_limit</code> <strong>酌情修改为2000M</strong></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619153003.png" alt="image-20200807133917750"></p><p>开启 <em><strong>文件上传</strong></em>  ,查找：<code>file_uploads</code> 更改为<code>On</code></p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619153007.png" alt="image-20200807134107318"></p><ul><li><p>更改完成后重启 <code>nginx+php-fpm</code> </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">max_input_time</span> = <span class="hljs-number">3600</span><span class="hljs-comment">;sudo systemctl restart nginxsudo systemctl restart php7.3-fpm</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>更改后的探针页面</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619153012.png" alt="image-20200807134706542"></p><h2 id="8-搭建kodbox云私有云盘"><a href="#8-搭建kodbox云私有云盘" class="headerlink" title="8.搭建kodbox云私有云盘"></a>8.搭建<code>kodbox</code>云私有云盘</h2><blockquote><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><h4 id="即刻下载，开启私有云盘之旅"><a href="#即刻下载，开启私有云盘之旅" class="headerlink" title="即刻下载，开启私有云盘之旅"></a>即刻下载，开启私有云盘之旅</h4><p><strong>官网:<a href="http://kodcloud.com/download/">可道云官网</a></strong></p></blockquote><ul><li><strong>下载源码</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~mkdir kodboxcd kodboxwget http://static.kodcloud.com/update/download/kodbox.1.11.zipunzip kodbox.1.11.zipunzip kodbox.1.11.ziprm kodbox.1.11.zipchmod 777 ~/kodbox<br></code></pre></td></tr></table></figure><p>尝试访问 <strong>http:&#x2F;&#x2F;树莓派ip:88</strong> :</p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619153018.png" alt="image-20200805163537543"></p><blockquote><p>除了PHP版本外其他都可以通过哒~</p></blockquote><ul><li><p>安装系统缓存<code>Redis</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install redis php-redis<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619153025.png" alt="image-20200805164115135"></p></li></ul><p><strong>redis服务会自动运行自动添加开机启动项，省心！！！</strong></p><p><strong>编辑</strong><code>sudo nano /etc/php/7.3/fpm/php.ini </code>文件加入：</p><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619153032.png" alt="image-20200807211906533"></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">extension</span>=redis.so<span class="hljs-comment">#重启php-fpmsudo systemctl restart php7.3-fpm </span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/AdminWhaleFall/Pic@master/img/20210619153038.png" alt="image-20200805164305612"></p><blockquote><h4 id="数据库选择MySQL，填入自己的密码"><a href="#数据库选择MySQL，填入自己的密码" class="headerlink" title="数据库选择MySQL，填入自己的密码"></a>数据库选择<strong>MySQL</strong>，填入自己的密码</h4><h4 id="系统缓存类型选择Redis"><a href="#系统缓存类型选择Redis" class="headerlink" title="系统缓存类型选择Redis"></a>系统缓存类型选择Redis</h4></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Respi</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
